# PlantUML + 생성형 AI 활용

## 목차
- [PlantUML 소개](#plantuml-소개)
- [기본 문법](#기본-문법)
- [다이어그램 유형](#다이어그램-유형)
    - [시퀀스 다이어그램](#시퀀스-다이어그램)
    - [클래스 다이어그램](#클래스-다이어그램)
    - [유스케이스 다이어그램](#유스케이스-다이어그램)
    - [활동 다이어그램](#활동-다이어그램)
    - [상태 다이어그램](#상태-다이어그램)
    - [컴포넌트 다이어그램](#컴포넌트-다이어그램)
    - [배포 다이어그램](#배포-다이어그램)
    - [객체 다이어그램](#객체-다이어그램)
    - [타이밍 다이어그램](#타이밍-다이어그램)
    - [ER 다이어그램](#er-다이어그램)
    - [네트워크 다이어그램](#네트워크-다이어그램)
    - [마인드맵](#마인드맵)
    - [WBS (Work Breakdown Structure)](#wbs-work-breakdown-structure)
    - [간트 차트](#간트-차트)
- [스타일링 및 테마](#스타일링-및-테마)
- [고급 기능](#고급-기능)
- [생성형 AI와 통합](#생성형-ai와-통합)
- [팁과 모범 사례](#팁과-모범-사례)

## PlantUML 소개

PlantUML은 텍스트 기반으로 UML(Unified Modeling Language) 다이어그램을 생성하는 오픈소스 도구다. 텍스트 형식으로 다이어그램을 정의해 버전 관리 시스템과 함께 사용하기 쉽고, 코드로서의 다이어그램(Diagram as Code) 개념을 구현한다.

### PlantUML의 장점
- 텍스트 기반으로 버전 관리 용이
- 다양한 UML 다이어그램 지원
- 커스터마이징 가능
- 다양한 통합 지원 (IDE, 위키, 문서 도구)
- 오픈 소스

## 기본 문법

모든 PlantUML 다이어그램은 다음 기본 구조를 따른다:

```
@startuml [파일명]
  // 다이어그램 내용
@enduml
```

또는 특정 다이어그램을 명시적으로 지정할 수도 있다:

```
@startclass
  // 클래스 다이어그램 내용
@endclass

@startsequence
  // 시퀀스 다이어그램 내용
@endsequence
```

### 주석
```
' 이것은 한 줄 주석
/' 이것은
   여러 줄
   주석 '/
```

### 공통 스타일링 옵션
```
skinparam {
  paramName value
}
```

## 다이어그램 유형

### 시퀀스 다이어그램

시퀀스 다이어그램은 객체 간의 상호작용을 시간 순서대로 표현한다.

#### 기본 예제
```
@startuml
actor 사용자
participant "첫 번째 클래스" as A
participant "두 번째 클래스" as B
participant "마지막 클래스" as C

사용자 -> A: 요청
activate A
A -> B: 위임
activate B
B -> C: 요청
activate C
C --> B: 응답
destroy C
B --> A: 응답
deactivate B
A --> 사용자: 응답
deactivate A
@enduml
```

#### 참가자 정의
```
actor 액터명
boundary 경계명
control 컨트롤명
entity 엔티티명
database 데이터베이스명
collections 컬렉션명
participant 참가자명
```

#### 메시지 유형
```
-> : 실선 화살표
--> : 점선 화살표
->> : 열린 화살표
->x : 손실 메시지
->o : 발견 메시지
<-> : 양방향 메시지
```

#### 활성화 및 비활성화
```
activate A
deactivate A
destroy A
```

#### 그룹화
```
alt 조건
  // 메시지
else 다른 조건
  // 메시지
end

loop 반복 조건
  // 메시지
end

par 병렬 처리
  // 메시지
and
  // 메시지
end
```

#### 노트
```
note left of A: 왼쪽 노트
note right of A: 오른쪽 노트
note over A,B: 여러 참가자에 걸친 노트
```

### 클래스 다이어그램

클래스 다이어그램은 시스템의 클래스, 속성, 메서드 및 관계를 표현한다.

#### 기본 예제
```
@startuml
class Animal {
  +name: String
  +age: int
  +makeSound(): void
  -privateMethod(): void
}

class Dog {
  +breed: String
  +fetch(): void
}

class Cat {
  +color: String
  +climb(): void
}

Animal <|-- Dog
Animal <|-- Cat
@enduml
```

#### 접근 제한자
```
+ : 공개(public)
- : 비공개(private)
# : 보호(protected)
~ : 패키지(package/default)
```

#### 관계 유형
```
<|-- : 상속/일반화
*-- : 컴포지션
o-- : 집합
<-- : 연관
<.. : 의존
..|> : 인터페이스 구현
-- : 양방향 연관
```

#### 관계에 설명 추가
```
A "1" -- "n" B : contains
```

#### 추상 클래스 및 인터페이스
```
abstract class AbstractClass
interface Interface
```

#### 패키지
```
package "패키지명" {
  // 클래스들
}
```

#### 스테레오타입
```
class User << (S,#FF7700) Singleton >>
```

### 유스케이스 다이어그램

유스케이스 다이어그램은 사용자와 시스템 간의 상호작용을 표현한다.

#### 기본 예제
```
@startuml
left to right direction
actor 고객
actor 판매자
rectangle 쇼핑시스템 {
  usecase "상품 검색" as UC1
  usecase "장바구니 관리" as UC2
  usecase "주문하기" as UC3
  usecase "결제하기" as UC4
}

고객 --> UC1
고객 --> UC2
고객 --> UC3
고객 --> UC4
UC3 ..> UC4 : <<include>>
판매자 --> UC4
@enduml
```

#### 관계 유형
```
--> : 연관
..> : 의존
.> : 확장 (<<extend>>)
.> : 포함 (<<include>>)
-|> : 일반화
```

#### 노트
```
note left of UC1 : 이것은 노트
```

### 활동 다이어그램

활동 다이어그램은 프로세스나 알고리즘의 흐름을 표현한다.

#### 기본 예제
```
@startuml
start
:사용자 로그인;
if (인증 성공?) then (yes)
  :대시보드 표시;
  :작업 수행;
else (no)
  :에러 메시지 표시;
  :로그인 페이지;
endif
:로그아웃;
stop
@enduml
```

#### 액티비티
```
:액티비티 텍스트;
```

#### 분기
```
if (조건) then (yes)
  // 작업
else (no)
  // 작업
endif
```

#### 반복
```
while (조건)
  // 작업
endwhile

repeat
  // 작업
repeat while (조건)
```

#### 병렬 처리
```
fork
  // 병렬 작업 1
fork again
  // 병렬 작업 2
end fork
```

#### 파티션
```
partition "파티션 이름" {
  // 액티비티
}
```

#### 스윔레인
```
|스윔레인1|
:액티비티1;
|스윔레인2|
:액티비티2;
```

### 상태 다이어그램

상태 다이어그램은 객체의 상태 변화와 이벤트를 표현한다.

#### 기본 예제
```
@startuml
[*] --> 초기상태
초기상태 --> 처리중 : 시작
처리중 --> 완료 : 처리 완료
처리중 --> 에러 : 오류 발생
에러 --> 처리중 : 재시도
완료 --> [*]
@enduml
```

#### 상태
```
state "상태 이름" as 상태ID
```

#### 복합 상태
```
state 상위상태 {
  [*] --> 하위상태1
  하위상태1 --> 하위상태2
  하위상태2 --> [*]
}
```

#### 노트
```
note left of 상태 : 노트 내용
```

#### 히스토리
```
상태1 --> H : 이벤트
H --> 상태2
```

### 컴포넌트 다이어그램

컴포넌트 다이어그램은 시스템의 구성 요소와 그들 간의 의존성을 표현한다.

#### 기본 예제
```
@startuml
package "프론트엔드" {
  [웹 클라이언트]
}

package "백엔드" {
  [API 서버]
  [인증 서비스]
  [결제 처리]
  database "사용자 DB"
  database "주문 DB"
}

[웹 클라이언트] --> [API 서버]
[API 서버] --> [인증 서비스]
[API 서버] --> [결제 처리]
[인증 서비스] --> [사용자 DB]
[API 서버] --> [주문 DB]
@enduml
```

#### 컴포넌트 표현
```
[컴포넌트명]
component [컴포넌트명]
```

#### 인터페이스
```
() "인터페이스명"
```

#### 포트
```
[컴포넌트] #-- ()
```

### 배포 다이어그램

배포 다이어그램은 하드웨어 및 소프트웨어 컴포넌트의 물리적 배치를 표현한다.

#### 기본 예제
```
@startuml
cloud "클라우드" {
  node "웹 서버" {
    [프론트엔드 앱]
  }
  
  node "애플리케이션 서버" {
    [백엔드 API]
  }
  
  database "데이터베이스 서버" {
    [SQL DB]
  }
}

node "클라이언트 기기" {
  [웹 브라우저]
}

[웹 브라우저] --> [프론트엔드 앱]
[프론트엔드 앱] --> [백엔드 API]
[백엔드 API] --> [SQL DB]
@enduml
```

#### 노드 표현
```
node 노드명
```

#### 아티팩트
```
artifact 아티팩트명
```

#### 네트워크
```
cloud 클라우드명
```

### 객체 다이어그램

객체 다이어그램은 클래스의 인스턴스와 그들 간의 관계를 표현한다.

#### 기본 예제
```
@startuml
object 고객1 {
  이름 = "홍길동"
  이메일 = "hong@example.com"
}

object 주문1 {
  주문번호 = "ORD-12345"
  금액 = 50000
}

object 상품1 {
  상품명 = "스마트폰"
  가격 = 50000
}

고객1 --> 주문1 : 주문함
주문1 o--> 상품1 : 포함함
@enduml
```

#### 객체 표현
```
object 객체명
```

#### 맵 표현
```
map 맵명 {
  key1 => value1
  key2 => value2
}
```

### 타이밍 다이어그램

타이밍 다이어그램은 시간 경과에 따른 상태 변화를 표현한다.

#### 기본 예제
```
@startuml
robust "웹 서버" as WEB
robust "데이터베이스" as DB
concise "사용자" as USER

@0
USER is 대기
WEB is 유휴
DB is 유휴

@+1
USER -> WEB : 요청
USER is 요청중
WEB is 처리중

@+1
WEB -> DB : 쿼리
WEB is 대기
DB is 처리중

@+1
DB is 응답
DB -> WEB : 결과
WEB is 처리중

@+1
WEB -> USER : 응답
WEB is 유휴
DB is 유휴
USER is 대기
@enduml
```

#### 타이밍 표현
```
@시간
객체 is 상태
객체1 -> 객체2 : 메시지
```

### ER 다이어그램

ER(Entity-Relationship) 다이어그램은 데이터베이스의 구조를 표현한다.

#### 기본 예제
```
@startuml
entity 고객 {
  * 고객ID : number <<PK>>
  --
  * 이름 : string
  * 이메일 : string
  주소 : string
  생성일 : date
}

entity 주문 {
  * 주문ID : number <<PK>>
  --
  * 고객ID : number <<FK>>
  주문일 : date
  총액 : number
}

entity 상품 {
  * 상품ID : number <<PK>>
  --
  * 상품명 : string
  가격 : number
  재고 : number
}

entity 주문상세 {
  * 주문ID : number <<PK, FK>>
  * 상품ID : number <<PK, FK>>
  --
  수량 : number
  단가 : number
}

고객 ||--o{ 주문
주문 ||--|{ 주문상세
상품 }|--|| 주문상세
@enduml
```

#### 엔티티 표현
```
entity 엔티티명 {
  * 필수속성 : 타입 <<제약조건>>
  선택속성 : 타입
  --
  * 다른속성 : 타입
}
```

#### 관계 표현
```
|o--o| : 일대일 (선택적)
||--|| : 일대일 (필수적)
|o--|| : 일대일 (한쪽은 선택적)
||--o{ : 일대다 (다쪽은 선택적)
||--|{ : 일대다 (필수적)
}|--|| : 다대일
}o--o{ : 다대다
```

### 네트워크 다이어그램

네트워크 다이어그램은 네트워크 토폴로지를 표현한다.

#### 기본 예제
```
@startuml
nwdiag {
  network 인터넷 {
    라우터 [address = "외부 IP"];
  }
  
  network 내부망 {
    address = "192.168.1.0/24"
    라우터 [address = "192.168.1.1"];
    웹서버 [address = "192.168.1.10"];
    DB서버 [address = "192.168.1.20"];
  }
  
  network DMZ {
    address = "192.168.2.0/24"
    라우터 [address = "192.168.2.1"];
    프록시 [address = "192.168.2.10"];
  }
}
@enduml
```

#### 네트워크 정의
```
network 네트워크명 {
  address = "주소"
  장비 [address = "IP"];
}
```

### 마인드맵

마인드맵은 아이디어나 개념 간의 관계를 시각적으로 표현한다.

#### 기본 예제
```
@startmindmap
* 프로젝트 계획
** 요구사항 분석
*** 사용자 인터뷰
*** 시장 조사
** 설계
*** UI/UX 설계
*** 데이터베이스 설계
*** API 설계
** 개발
*** 프론트엔드
**** React
**** CSS
*** 백엔드
**** API 서버
**** 데이터베이스
** 테스트
*** 단위 테스트
*** 통합 테스트
*** UI 테스트
** 배포
*** CI/CD 구성
*** 인프라 구축
@endmindmap
```

#### 방향 지정
```
@startmindmap
<style>
mindmapDiagram {
  .green {
    BackgroundColor lightgreen
  }
  .rose {
    BackgroundColor #FFBBCC
  }
}
</style>
* 루트 <<green>>
** 오른쪽 1 <<rose>>
** 오른쪽 2
left side
** 왼쪽 1
** 왼쪽 2
@endmindmap
```

### WBS (Work Breakdown Structure)

WBS는 프로젝트 작업 분해도를 표현한다.

#### 기본 예제
```
@startwbs
* 프로젝트
** 기획
*** 요구사항 분석
*** 기능 명세
** 설계
*** 아키텍처 설계
*** UI/UX 설계
** 개발
*** 프론트엔드 개발
**** 컴포넌트 구현
**** 상태 관리
*** 백엔드 개발
**** API 구현
**** 데이터베이스 연동
** 테스트
*** 단위 테스트
*** 통합 테스트
** 배포
*** 스테이징 배포
*** 프로덕션 배포
@endwbs
```

### 간트 차트

간트 차트는 프로젝트 일정을 표현한다.

#### 기본 예제
```
@startgantt
project starts the 2023/01/01
[요구사항 분석] lasts 10 days
[설계] lasts 15 days
[설계] starts at [요구사항 분석]'s end
[개발] lasts 30 days
[개발] starts at [설계]'s end
[테스트] lasts 15 days
[테스트] starts at [개발]'s end
[배포] lasts 5 days
[배포] starts at [테스트]'s end
@endgantt
```

#### 작업 정의
```
[작업명] lasts X days
[작업명] starts YYYY/MM/DD
[작업명] ends YYYY/MM/DD
```

#### 마일스톤
```
[마일스톤] happens YYYY/MM/DD
[마일스톤] happens at [작업]'s end
```

#### 의존성
```
[작업2] starts at [작업1]'s end
```

## 스타일링 및 테마

### 기본 스타일링
```
@startuml
skinparam backgroundColor #EEEBDC
skinparam handwritten true

skinparam sequence {
  ArrowColor DeepSkyBlue
  ActorBorderColor DeepSkyBlue
  LifeLineBorderColor blue
  LifeLineBackgroundColor #A9DCDF
  
  ParticipantBorderColor DeepSkyBlue
  ParticipantBackgroundColor DodgerBlue
  ParticipantFontName Impact
  ParticipantFontSize 17
  ParticipantFontColor #A9DCDF
  
  ActorBackgroundColor aqua
  ActorFontColor DeepSkyBlue
  ActorFontSize 17
  ActorFontName Aapex
}

actor User
participant "First Class" as A
participant "Second Class" as B
participant "Last Class" as C

User -> A: DoWork
activate A
A -> B: Create Request
activate B
B -> C: DoWork
activate C
C --> B: WorkDone
destroy C
B --> A: Request Created
deactivate B
A --> User: Done
deactivate A
@enduml
```

### 내장 테마 사용
```
@startuml
!theme cerulean
// 다이어그램 내용
@enduml
```

사용 가능한 내장 테마:
- amiga
- aws-orange
- black-knight
- cerulean
- crt-amber
- crt-green
- cyborg
- hacker
- materia
- minty
- sketchy
- superhero
- toy

### 사용자 정의 테마
```
@startuml
!theme black-knight

!define PRIMARY #8be9fd
!define SECONDARY #bd93f9
!define SUCCESS #50fa7b
!define INFO #f1fa8c
!define WARNING #ffb86c
!define DANGER #ff5555

skinparam backgroundColor #282a36
skinparam BorderColor white

skinparam ClassAttributeFontColor #f8f8f2
skinparam ClassBackgroundColor #44475a
skinparam ClassBorderColor #f8f8f2

// 다이어그램 내용
@enduml
```

## 고급 기능

### 다이어그램 포함
```
@startuml
!include path/to/other.puml
!includesub path/to/other.puml!SUBPART
@enduml
```

### 매크로 정의
```
!definelong CUSTOM_ELEMENT
class Example {
  +standard_fields
  +custom_method()
}
!enddefinelong

CUSTOM_ELEMENT
```

### 변수 사용
```
!$color = "red"
!$name = "Product"

class $name {
  +id: int
}

skinparam class {
  BackgroundColor $color
}
```

### 조건부 프리프로세싱
```
!if (%not(%variable_exists("$BGCOLOR")))
  !$BGCOLOR = "white"
!endif

skinparam backgroundColor $BGCOLOR
```

### 스프라이트 사용
```
@startuml
sprite $dog [15x15/8] {
  0000000000000000
  0000000000000000
  0011111111111000
  0111111111111100
  0111111111111100
  0111111111111100
  0111111111111100
  0011111111111000
  0001111111110000
  0001111111100000
  0000111111000000
  0000111110000000
  0000011100000000
  0000000000000000
  0000000000000000
  0000000000000000
}

class Dog {
  {sprite}$dog
}
@enduml
```

### 신호등 다이어그램
```
@startuml
binary "입력 신호" as I
state "처리 상태" as P
state "대기 상태" as W

[*] --> W
W --> P : 이벤트 발생
P --> W : 처리 완료
@enduml
```

## 생성형 AI와 통합

생성형 AI를 활용해 PlantUML 다이어그램을 생성하고 개선하는 방법.

### 자연어에서 다이어그램 생성

#### 예제 1: 마이크로서비스 아키텍처
입력:
```
"주문 관리, 재고 관리, 결제 처리, 배송 추적, 사용자 관리 기능을 가진 이커머스 마이크로서비스 아키텍처를 설계해주세요."
```

AI 생성 결과:
```
@startuml
!define ICONURL https://raw.githubusercontent.com/tupadr3/plantuml-icon-font-sprites/master/devicons
!includeurl ICONURL/java.puml
!includeurl ICONURL/nodejs.puml
!includeurl ICONURL/python.puml
!includeurl ICONURL/mongodb.puml
!includeurl ICONURL/postgresql.puml
!includeurl ICONURL/redis.puml

skinparam componentStyle rectangle

cloud "클라이언트" {
  [모바일 앱]
  [웹 앱]
}

node "API Gateway" {
  [API 라우팅]
  [인증/인가]
  [부하 분산]
  [캐싱]
}

node "서비스" {
  frame "주문 서비스" <<java>> {
    [주문 관리 API]
    [주문 처리 로직]
    database "주문 DB" <<postgresql>>
  }
  
  frame "재고 서비스" <<python>> {
    [재고 관리 API]
    [재고 처리 로직]
    database "재고 DB" <<mongodb>>
  }
  
  frame "결제 서비스" <<nodejs>> {
    [결제 API]
    [결제 처리 로직]
    [외부 결제 연동]
    database "결제 DB" <<postgresql>>
  }
  
  frame "배송 서비스" <<java>> {
    [배송 API]
    [배송 추적 로직]
    [외부 배송사 연동]
    database "배송 DB" <<mongodb>>
  }
  
  frame "사용자 서비스" <<nodejs>> {
    [사용자 API]
    [인증 로직]
    [프로필 관리]
    database "사용자 DB" <<postgresql>>
  }
  
  database "캐시 저장소" <<redis>>
}

node "메시징" {
  [이벤트 버스]
  [메시지 큐]
}

node "모니터링 & 로깅" {
  [로그 수집]
  [메트릭 수집]
  [알림]
  database "로그 저장소"
}

' 클라이언트와 API Gateway 연결
[모바일 앱] --> [API 라우팅]
[웹 앱] --> [API 라우팅]

' API Gateway와 서비스 연결
[API 라우팅] --> [주문 관리 API]
[API 라우팅] --> [재고 관리 API]
[API 라우팅] --> [결제 API]
[API 라우팅] --> [배송 API]
[API 라우팅] --> [사용자 API]

' 서비스 간 연결
[주문 처리 로직] ..> [이벤트 버스] : 주문 생성됨
[재고 처리 로직] <.. [이벤트 버스] : 주문 생성됨
[결제 처리 로직] <.. [이벤트 버스] : 주문 생성됨
[배송 추적 로직] <.. [이벤트 버스] : 결제 완료됨

' 데이터베이스 연결
[주문 처리 로직] --> [주문 DB]
[재고 처리 로직] --> [재고 DB]
[결제 처리 로직] --> [결제 DB]
[배송 추적 로직] --> [배송 DB]
[사용자 API] --> [사용자 DB]

' 캐시 연결
[주문 관리 API] --> [캐시 저장소]
[재고 관리 API] --> [캐시 저장소]
[결제 API] --> [캐시 저장소]
[배송 API] --> [캐시 저장소]
[사용자 API] --> [캐시 저장소]

' 로깅 연결
[주문 관리 API] ..> [로그 수집] : 로그
[재고 관리 API] ..> [로그 수집] : 로그
[결제 API] ..> [로그 수집] : 로그
[배송 API] ..> [로그 수집] : 로그
[사용자 API] ..> [로그 수집] : 로그

@enduml
```

#### 예제 2: 상태 기계 다이어그램
입력:
```
"주문 처리 시스템의 상태 다이어그램을 만들어주세요. 상태는 생성됨, 결제 대기, 결제 완료, 배송 준비, 배송 중, 배송 완료, 취소됨이 있습니다. 각 상태 간의 전이 조건도 포함해주세요."
```

AI 생성 결과:
```
@startuml
skinparam state {
  BackgroundColor LightBlue
  BorderColor DarkBlue
  ArrowColor DarkBlue
  
  BackgroundColor<<Warning>> LightYellow
  BorderColor<<Warning>> DarkGoldenRod
  
  BackgroundColor<<Success>> LightGreen
  BorderColor<<Success>> DarkGreen
  
  BackgroundColor<<Danger>> Salmon
  BorderColor<<Danger>> DarkRed
}

[*] --> 생성됨 : 주문 작성
생성됨 --> 결제대기 : 주문 확인
생성됨 --> 취소됨 : 사용자 취소
결제대기 --> 결제완료 : 결제 승인
결제대기 --> 취소됨 : 사용자 취소 / 결제 실패 / 결제 시간 초과
결제완료 --> 배송준비 : 주문 처리 시작
결제완료 --> 취소됨 : 재고 부족 / 관리자 취소
배송준비 --> 배송중 : 택배사 인계
배송준비 --> 취소됨 : 배송 불가 / 관리자 취소
배송중 --> 배송완료 : 배송 확인
배송중 --> 취소됨 : 배송 실패
배송완료 --> [*]
취소됨 --> [*]

state 생성됨
state 결제대기
state 결제완료 <<Success>>
state 배송준비
state 배송중 <<Warning>>
state 배송완료 <<Success>>
state 취소됨 <<Danger>>

note right of 생성됨
  주문이 생성되었지만
  아직 결제가 진행되지 않음
end note

note right of 결제대기
  결제 진행 중,
  시간 제한: 30분
end note

note right of 취소됨
  주문이 취소된 상태.
  재고는 원상복구되며
  환불 프로세스가 시작됨.
end note
@enduml
```

### 코드에서 다이어그램 추출

다음은 간단한 typescript 클래스 코드를 기반으로 클래스 다이어그램을 생성하는 예제다.

#### typescript 코드:
```typescript
class User {
  private user_id: string;
  private name: string;
  private email: string;
  private orders: Order[] = [];

  constructor(user_id: string, name: string, email: string) {
    this.user_id = user_id;
    this.name = name;
    this.email = email;
  }

  public addOrder(order: Order): void {
    this.orders.push(order);
  }

  public getOrders(): Order[] {
    return this.orders;
  }
}

class Order {
  private order_id: string;
  private user: User;
  private items: OrderItem[];
  private total_amount: number;
  private status: string = "CREATED";

  constructor(order_id: string, user: User, items: OrderItem[], total_amount: number) {
    this.order_id = order_id;
    this.user = user;
    this.items = items;
    this.total_amount = total_amount;
  }

  public process(): void {
    this.status = "PROCESSING";
  }

  public ship(): void {
    this.status = "SHIPPED";
  }

  public deliver(): void {
    this.status = "DELIVERED";
  }

  public cancel(): void {
    this.status = "CANCELLED";
  }
}

class OrderItem {
  private product: Product;
  private quantity: number;
  private price: number;

  constructor(product: Product, quantity: number, price: number) {
    this.product = product;
    this.quantity = quantity;
    this.price = price;
  }

  public getSubtotal(): number {
    return this.quantity * this.price;
  }
}

class Product {
  private product_id: string;
  private name: string;
  private price: number;
  private stock: number;

  constructor(product_id: string, name: string, price: number, stock: number) {
    this.product_id = product_id;
    this.name = name;
    this.price = price;
    this.stock = stock;
  }

  public updateStock(quantity: number): void {
    this.stock += quantity;
  }
}
```

#### 생성된 PlantUML 다이어그램:
```
@startuml
class User {
  -user_id
  -name
  -email
  -orders: List[Order]
  +add_order(order: Order): void
  +get_orders(): List[Order]
}

class Order {
  -order_id
  -user: User
  -items: List[OrderItem]
  -total_amount
  -status: String
  +process(): void
  +ship(): void
  +deliver(): void
  +cancel(): void
}

class OrderItem {
  -product: Product
  -quantity: int
  -price: float
  +get_subtotal(): float
}

class Product {
  -product_id
  -name
  -price
  -stock
  +update_stock(quantity: int): void
}

User "1" --> "0..*" Order: has
Order "1" --> "1..*" OrderItem: contains
OrderItem "0..*" --> "1" Product: references
@enduml
```

### 다이어그램 개선 및 리팩토링

생성형 AI는 기존 다이어그램을 분석하고 개선하는 데 도움을 준다.

#### 개선 전 다이어그램:
```
@startuml
[클라이언트] --> [서버]
[서버] --> [데이터베이스]
@enduml
```

#### 개선 요청:
```
"이 시스템에 로드 밸런서, 캐싱 레이어, 마이크로서비스 아키텍처를 적용하여 개선해주세요."
```

#### 개선 후 다이어그램:
```
@startuml
skinparam componentStyle rectangle
skinparam monochrome true
skinparam shadowing false

cloud "외부" {
  [모바일 클라이언트]
  [웹 클라이언트]
}

node "인프라" {
  [CDN] as cdn
  [로드 밸런서] as lb
  
  node "서비스 계층" {
    [API 게이트웨이] as gateway
    
    package "마이크로서비스" {
      [사용자 서비스] as user_service
      [상품 서비스] as product_service
      [주문 서비스] as order_service
      [결제 서비스] as payment_service
    }
    
    [캐시 레이어] as cache
    
    database "데이터 계층" {
      [사용자 DB] as user_db
      [상품 DB] as product_db
      [주문 DB] as order_db
      [결제 DB] as payment_db
    }
  }
}

[모바일 클라이언트] --> cdn
[웹 클라이언트] --> cdn
cdn --> lb
lb --> gateway

gateway --> user_service
gateway --> product_service
gateway --> order_service
gateway --> payment_service

user_service --> cache
product_service --> cache
order_service --> cache
payment_service --> cache

cache --> user_db
cache --> product_db
cache --> order_db
cache --> payment_db

user_service --> user_db
product_service --> product_db
order_service --> order_db
payment_service --> payment_db

user_service <--> order_service : REST
product_service <--> order_service : REST
order_service <--> payment_service : REST
@enduml
```

## 팁과 모범 사례

### 다이어그램 복잡도 관리
1. **계층 구조 사용**: 복잡한 시스템은 여러 다이어그램으로 분리해 표현
2. **패키지 활용**: 관련 요소들을 패키지로 그룹화
3. **색상과 스타일링**: 중요한 요소를 시각적으로 구분
4. **노트 사용**: 복잡한 개념은 노트로 설명

### 일관성 유지
1. **명명 규칙**: 일관된 이름 지정 규칙 사용
2. **스타일 일관성**: 동일한 유형의 요소에 일관된 스타일 적용
3. **공통 요소 추출**: 반복되는 패턴은 매크로로 정의하여 재사용

### 가독성 향상
1. **적절한 레이아웃**: 요소 간 관계를 명확히 표현
2. **스페이싱**: 복잡한 다이어그램에 충분한 공간 확보
3. **간결한 텍스트**: 설명은 짧고 명확하게 작성

### 협업 및 버전 관리
1. **주석 사용**: 다른 사람이 이해할 수 있도록 주석 추가
2. **모듈화**: 재사용 가능한 다이어그램 구성 요소 만들기
3. **Git 통합**: PlantUML 파일을 Git으로 관리하여 버전 추적 및 협업 지원

### 생성형 AI 활용 최적화
1. **명확한 지시**: AI에게 다이어그램의 목적과 필요한 세부 사항을 구체적으로 설명
2. **반복적 개선**: 생성된 다이어그램을 점진적으로 개선
3. **요구사항 세분화**: 복잡한 다이어그램은 더 작은 부분으로 나누어 생성
4. **프롬프트 템플릿 활용**: 효과적인 프롬프트 패턴 재사용

## 생성형 AI와 통합하기 위한 프롬프트 템플릿

### 다이어그램 생성 템플릿
```
"다음 [시스템/프로세스/개념]에 대한 [다이어그램 유형] PlantUML 다이어그램을 생성:

요구사항:
1. [요구사항 1]
2. [요구사항 2]
...

포함해야 할 요소:
- [요소 1]
- [요소 2]
...

스타일 가이드라인:
- [스타일 가이드라인 1]
- [스타일 가이드라인 2]
..."
```

### 다이어그램 개선 템플릿
```
"다음 PlantUML 다이어그램을 개선:

```
[기존 다이어그램 코드]
```

개선 요청사항:
1. [개선 요청 1]
2. [개선 요청 2]
...

추가 고려사항:
- [고려사항 1]
- [고려사항 2]
..."
```

### 코드에서 다이어그램 추출 템플릿
```
"다음 [언어] 코드를 분석하여 [다이어그램 유형] PlantUML 다이어그램을 생성:

```
[소스 코드]
```

중점적으로 표현할 부분:
- [중점 1]
- [중점 2]
...

제외할 부분:
- [제외 1]
- [제외 2]# PlantUML + 생성형 AI 활용

## 목차
- [PlantUML 소개](#plantuml-소개)
- [기본 문법](#기본-문법)
- [다이어그램 유형](#다이어그램-유형)
    - [시퀀스 다이어그램](#시퀀스-다이어그램)
    - [클래스 다이어그램](#클래스-다이어그램)
    - [유스케이스 다이어그램](#유스케이스-다이어그램)
    - [활동 다이어그램](#활동-다이어그램)
    - [상태 다이어그램](#상태-다이어그램)
    - [컴포넌트 다이어그램](#컴포넌트-다이어그램)
    - [배포 다이어그램](#배포-다이어그램)
    - [객체 다이어그램](#객체-다이어그램)
    - [타이밍 다이어그램](#타이밍-다이어그램)
    - [ER 다이어그램](#er-다이어그램)
    - [네트워크 다이어그램](#네트워크-다이어그램)
    - [마인드맵](#마인드맵)
    - [WBS (Work Breakdown Structure)](#wbs-work-breakdown-structure)
    - [간트 차트](#간트-차트)
- [스타일링 및 테마](#스타일링-및-테마)
- [고급 기능](#고급-기능)
- [생성형 AI와 통합](#생성형-ai와-통합)
- [팁과 모범 사례](#팁과-모범-사례)

## PlantUML 소개

PlantUML은 텍스트 기반으로 UML(Unified Modeling Language) 다이어그램을 생성하는 오픈소스 도구다. 텍스트 형식으로 다이어그램을 정의해 버전 관리 시스템과 함께 사용하기 쉽고, 코드로서의 다이어그램(Diagram as Code) 개념을 구현한다.

### PlantUML의 장점
- 텍스트 기반으로 버전 관리 용이
- 다양한 UML 다이어그램 지원
- 커스터마이징 가능
- 다양한 통합 지원 (IDE, 위키, 문서 도구)
- 오픈 소스

## 기본 문법

모든 PlantUML 다이어그램은 다음 기본 구조를 따른다:

```
@startuml [파일명]
// 다이어그램 내용
@enduml
```

또는 특정 다이어그램을 명시적으로 지정할 수도 있다:

```
@startclass
// 클래스 다이어그램 내용
@endclass

@startsequence
// 시퀀스 다이어그램 내용
@endsequence
```

### 주석
```
' 이것은 한 줄 주석
/' 이것은
여러 줄
주석 '/
```

### 공통 스타일링 옵션
```
skinparam {
paramName value
}
```

## 다이어그램 유형

### 시퀀스 다이어그램

시퀀스 다이어그램은 객체 간의 상호작용을 시간 순서대로 표현한다.

#### 기본 예제
```
@startuml
actor 사용자
participant "첫 번째 클래스" as A
participant "두 번째 클래스" as B
participant "마지막 클래스" as C

사용자 -> A: 요청
activate A
A -> B: 위임
activate B
B -> C: 요청
activate C
C --> B: 응답
destroy C
B --> A: 응답
deactivate B
A --> 사용자: 응답
deactivate A
@enduml
```

#### 참가자 정의
```
actor 액터명
boundary 경계명
control 컨트롤명
entity 엔티티명
database 데이터베이스명
collections 컬렉션명
participant 참가자명
```

#### 메시지 유형
```
-> : 실선 화살표
--> : 점선 화살표
->> : 열린 화살표
->x : 손실 메시지
->o : 발견 메시지
<-> : 양방향 메시지
```

#### 활성화 및 비활성화
```
activate A
deactivate A
destroy A
```

#### 그룹화
```
alt 조건
// 메시지
else 다른 조건
// 메시지
end

loop 반복 조건
// 메시지
end

par 병렬 처리
// 메시지
and
// 메시지
end
```

#### 노트
```
note left of A: 왼쪽 노트
note right of A: 오른쪽 노트
note over A,B: 여러 참가자에 걸친 노트
```

### 클래스 다이어그램

클래스 다이어그램은 시스템의 클래스, 속성, 메서드 및 관계를 표현한다.

#### 기본 예제
```
@startuml
class Animal {
+name: String
+age: int
+makeSound(): void
-privateMethod(): void
}

class Dog {
+breed: String
+fetch(): void
}

class Cat {
+color: String
+climb(): void
}

Animal <|-- Dog
Animal <|-- Cat
@enduml
```

#### 접근 제한자
```
+ : 공개(public)
- : 비공개(private)
# : 보호(protected)
~ : 패키지(package/default)
```

#### 관계 유형
```
<|-- : 상속/일반화
*-- : 컴포지션
o-- : 집합
<-- : 연관
<.. : 의존
..|> : 인터페이스 구현
-- : 양방향 연관
```

#### 관계에 설명 추가
```
A "1" -- "n" B : contains
```

#### 추상 클래스 및 인터페이스
```
abstract class AbstractClass
interface Interface
```

#### 패키지
```
package "패키지명" {
// 클래스들
}
```

#### 스테레오타입
```
class User << (S,#FF7700) Singleton >>
```

### 유스케이스 다이어그램

유스케이스 다이어그램은 사용자와 시스템 간의 상호작용을 표현한다.

#### 기본 예제
```
@startuml
left to right direction
actor 고객
actor 판매자
rectangle 쇼핑시스템 {
usecase "상품 검색" as UC1
usecase "장바구니 관리" as UC2
usecase "주문하기" as UC3
usecase "결제하기" as UC4
}

고객 --> UC1
고객 --> UC2
고객 --> UC3
고객 --> UC4
UC3 ..> UC4 : <<include>>
판매자 --> UC4
@enduml
```

#### 관계 유형
```
--> : 연관
..> : 의존
.> : 확장 (<<extend>>)
.> : 포함 (<<include>>)
-|> : 일반화
```

#### 노트
```
note left of UC1 : 이것은 노트
```

### 활동 다이어그램

활동 다이어그램은 프로세스나 알고리즘의 흐름을 표현한다.

#### 기본 예제
```
@startuml
start
:사용자 로그인;
if (인증 성공?) then (yes)
:대시보드 표시;
:작업 수행;
else (no)
:에러 메시지 표시;
:로그인 페이지;
endif
:로그아웃;
stop
@enduml
```

#### 액티비티
```
:액티비티 텍스트;
```

#### 분기
```
if (조건) then (yes)
// 작업
else (no)
// 작업
endif
```

#### 반복
```
while (조건)
// 작업
endwhile

repeat
// 작업
repeat while (조건)
```

#### 병렬 처리
```
fork
// 병렬 작업 1
fork again
// 병렬 작업 2
end fork
```

#### 파티션
```
partition "파티션 이름" {
// 액티비티
}
```

#### 스윔레인
```
|스윔레인1|
:액티비티1;
|스윔레인2|
:액티비티2;
```

### 상태 다이어그램

상태 다이어그램은 객체의 상태 변화와 이벤트를 표현한다.

#### 기본 예제
```
@startuml
[*] --> 초기상태
초기상태 --> 처리중 : 시작
처리중 --> 완료 : 처리 완료
처리중 --> 에러 : 오류 발생
에러 --> 처리중 : 재시도
완료 --> [*]
@enduml
```

#### 상태
```
state "상태 이름" as 상태ID
```

#### 복합 상태
```
state 상위상태 {
[*] --> 하위상태1
하위상태1 --> 하위상태2
하위상태2 --> [*]
}
```

#### 노트
```
note left of 상태 : 노트 내용
```

#### 히스토리
```
상태1 --> H : 이벤트
H --> 상태2
```

### 컴포넌트 다이어그램

컴포넌트 다이어그램은 시스템의 구성 요소와 그들 간의 의존성을 표현한다.

#### 기본 예제
```
@startuml
package "프론트엔드" {
[웹 클라이언트]
}

package "백엔드" {
[API 서버]
[인증 서비스]
[결제 처리]
database "사용자 DB"
database "주문 DB"
}

[웹 클라이언트] --> [API 서버]
[API 서버] --> [인증 서비스]
[API 서버] --> [결제 처리]
[인증 서비스] --> [사용자 DB]
[API 서버] --> [주문 DB]
@enduml
```

#### 컴포넌트 표현
```
[컴포넌트명]
component [컴포넌트명]
```

#### 인터페이스
```
() "인터페이스명"
```

#### 포트
```
[컴포넌트] #-- ()
```

### 배포 다이어그램

배포 다이어그램은 하드웨어 및 소프트웨어 컴포넌트의 물리적 배치를 표현한다.

#### 기본 예제
```
@startuml
cloud "클라우드" {
node "웹 서버" {
[프론트엔드 앱]
}

node "애플리케이션 서버" {
[백엔드 API]
}

database "데이터베이스 서버" {
[SQL DB]
}
}

node "클라이언트 기기" {
[웹 브라우저]
}

[웹 브라우저] --> [프론트엔드 앱]
[프론트엔드 앱] --> [백엔드 API]
[백엔드 API] --> [SQL DB]
@enduml
```

#### 노드 표현
```
node 노드명
```

#### 아티팩트
```
artifact 아티팩트명
```

#### 네트워크
```
cloud 클라우드명
```

### 객체 다이어그램

객체 다이어그램은 클래스의 인스턴스와 그들 간의 관계를 표현한다.

#### 기본 예제
```
@startuml
object 고객1 {
이름 = "홍길동"
이메일 = "hong@example.com"
}

object 주문1 {
주문번호 = "ORD-12345"
금액 = 50000
}

object 상품1 {
상품명 = "스마트폰"
가격 = 50000
}

고객1 --> 주문1 : 주문함
주문1 o--> 상품1 : 포함함
@enduml
```

#### 객체 표현
```
object 객체명
```

#### 맵 표현
```
map 맵명 {
key1 => value1
key2 => value2
}
```

### 타이밍 다이어그램

타이밍 다이어그램은 시간 경과에 따른 상태 변화를 표현한다.

#### 기본 예제
```
@startuml
robust "웹 서버" as WEB
robust "데이터베이스" as DB
concise "사용자" as USER

@0
USER is 대기
WEB is 유휴
DB is 유휴

@+1
USER -> WEB : 요청
USER is 요청중
WEB is 처리중

@+1
WEB -> DB : 쿼리
WEB is 대기
DB is 처리중

@+1
DB is 응답
DB -> WEB : 결과
WEB is 처리중

@+1
WEB -> USER : 응답
WEB is 유휴
DB is 유휴
USER is 대기
@enduml
```

#### 타이밍 표현
```
@시간
객체 is 상태
객체1 -> 객체2 : 메시지
```

### ER 다이어그램

ER(Entity-Relationship) 다이어그램은 데이터베이스의 구조를 표현한다.

#### 기본 예제
```
@startuml
entity 고객 {
* 고객ID : number <<PK>>
  --
* 이름 : string
* 이메일 : string
  주소 : string
  생성일 : date
  }

entity 주문 {
* 주문ID : number <<PK>>
  --
* 고객ID : number <<FK>>
  주문일 : date
  총액 : number
  }

entity 상품 {
* 상품ID : number <<PK>>
  --
* 상품명 : string
  가격 : number
  재고 : number
  }

entity 주문상세 {
* 주문ID : number <<PK, FK>>
* 상품ID : number <<PK, FK>>
  --
  수량 : number
  단가 : number
  }

고객 ||--o{ 주문
주문 ||--|{ 주문상세
상품 }|--|| 주문상세
@enduml
```

#### 엔티티 표현
```
entity 엔티티명 {
* 필수속성 : 타입 <<제약조건>>
  선택속성 : 타입
  --
* 다른속성 : 타입
  }
```

#### 관계 표현
```
|o--o| : 일대일 (선택적)
||--|| : 일대일 (필수적)
|o--|| : 일대일 (한쪽은 선택적)
||--o{ : 일대다 (다쪽은 선택적)
||--|{ : 일대다 (필수적)
}|--|| : 다대일
}o--o{ : 다대다
```

### 네트워크 다이어그램

네트워크 다이어그램은 네트워크 토폴로지를 표현한다.

#### 기본 예제
```
@startuml
nwdiag {
network 인터넷 {
라우터 [address = "외부 IP"];
}

network 내부망 {
address = "192.168.1.0/24"
라우터 [address = "192.168.1.1"];
웹서버 [address = "192.168.1.10"];
DB서버 [address = "192.168.1.20"];
}

network DMZ {
address = "192.168.2.0/24"
라우터 [address = "192.168.2.1"];
프록시 [address = "192.168.2.10"];
}
}
@enduml
```

#### 네트워크 정의
```
network 네트워크명 {
address = "주소"
장비 [address = "IP"];
}
```

### 마인드맵

마인드맵은 아이디어나 개념 간의 관계를 시각적으로 표현한다.

#### 기본 예제
```
@startmindmap
* 프로젝트 계획
  ** 요구사항 분석
  *** 사용자 인터뷰
  *** 시장 조사
  ** 설계
  *** UI/UX 설계
  *** 데이터베이스 설계
  *** API 설계
  ** 개발
  *** 프론트엔드
  **** React
  **** CSS
  *** 백엔드
  **** API 서버
  **** 데이터베이스
  ** 테스트
  *** 단위 테스트
  *** 통합 테스트
  *** UI 테스트
  ** 배포
  *** CI/CD 구성
  *** 인프라 구축
  @endmindmap
```

#### 방향 지정
```
@startmindmap
<style>
mindmapDiagram {
  .green {
    BackgroundColor lightgreen
  }
  .rose {
    BackgroundColor #FFBBCC
  }
}
</style>
* 루트 <<green>>
  ** 오른쪽 1 <<rose>>
  ** 오른쪽 2
  left side
  ** 왼쪽 1
  ** 왼쪽 2
  @endmindmap
```

### WBS (Work Breakdown Structure)

WBS는 프로젝트 작업 분해도를 표현한다.

#### 기본 예제
```
@startwbs
* 프로젝트
  ** 기획
  *** 요구사항 분석
  *** 기능 명세
  ** 설계
  *** 아키텍처 설계
  *** UI/UX 설계
  ** 개발
  *** 프론트엔드 개발
  **** 컴포넌트 구현
  **** 상태 관리
  *** 백엔드 개발
  **** API 구현
  **** 데이터베이스 연동
  ** 테스트
  *** 단위 테스트
  *** 통합 테스트
  ** 배포
  *** 스테이징 배포
  *** 프로덕션 배포
  @endwbs
```

### 간트 차트

간트 차트는 프로젝트 일정을 표현한다.

#### 기본 예제
```
@startgantt
project starts the 2023/01/01
[요구사항 분석] lasts 10 days
[설계] lasts 15 days
[설계] starts at [요구사항 분석]'s end
[개발] lasts 30 days
[개발] starts at [설계]'s end
[테스트] lasts 15 days
[테스트] starts at [개발]'s end
[배포] lasts 5 days
[배포] starts at [테스트]'s end
@endgantt
```

#### 작업 정의
```
[작업명] lasts X days
[작업명] starts YYYY/MM/DD
[작업명] ends YYYY/MM/DD
```

#### 마일스톤
```
[마일스톤] happens YYYY/MM/DD
[마일스톤] happens at [작업]'s end
```

#### 의존성
```
[작업2] starts at [작업1]'s end
```

## 스타일링 및 테마

### 기본 스타일링
```
@startuml
skinparam backgroundColor #EEEBDC
skinparam handwritten true

skinparam sequence {
ArrowColor DeepSkyBlue
ActorBorderColor DeepSkyBlue
LifeLineBorderColor blue
LifeLineBackgroundColor #A9DCDF

ParticipantBorderColor DeepSkyBlue
ParticipantBackgroundColor DodgerBlue
ParticipantFontName Impact
ParticipantFontSize 17
ParticipantFontColor #A9DCDF

ActorBackgroundColor aqua
ActorFontColor DeepSkyBlue
ActorFontSize 17
ActorFontName Aapex
}

actor User
participant "First Class" as A
participant "Second Class" as B
participant "Last Class" as C

User -> A: DoWork
activate A
A -> B: Create Request
activate B
B -> C: DoWork
activate C
C --> B: WorkDone
destroy C
B --> A: Request Created
deactivate B
A --> User: Done
deactivate A
@enduml
```

### 내장 테마 사용
```
@startuml
!theme cerulean
// 다이어그램 내용
@enduml
```

사용 가능한 내장 테마:
- amiga
- aws-orange
- black-knight
- cerulean
- crt-amber
- crt-green
- cyborg
- hacker
- materia
- minty
- sketchy
- superhero
- toy

### 사용자 정의 테마
```
@startuml
!theme black-knight

!define PRIMARY #8be9fd
!define SECONDARY #bd93f9
!define SUCCESS #50fa7b
!define INFO #f1fa8c
!define WARNING #ffb86c
!define DANGER #ff5555

skinparam backgroundColor #282a36
skinparam BorderColor white

skinparam ClassAttributeFontColor #f8f8f2
skinparam ClassBackgroundColor #44475a
skinparam ClassBorderColor #f8f8f2

// 다이어그램 내용
@enduml
```

## 고급 기능

### 다이어그램 포함
```
@startuml
!include path/to/other.puml
!includesub path/to/other.puml!SUBPART
@enduml
```

### 매크로 정의
```
!definelong CUSTOM_ELEMENT
class Example {
+standard_fields
+custom_method()
}
!enddefinelong

CUSTOM_ELEMENT
```

### 변수 사용
```
!$color = "red"
!$name = "Product"

class $name {
+id: int
}

skinparam class {
BackgroundColor $color
}
```

### 조건부 프리프로세싱
```
!if (%not(%variable_exists("$BGCOLOR")))
!$BGCOLOR = "white"
!endif

skinparam backgroundColor $BGCOLOR
```

### 스프라이트 사용
```
@startuml
sprite $dog [15x15/8] {
0000000000000000
0000000000000000
0011111111111000
0111111111111100
0111111111111100
0111111111111100
0111111111111100
0011111111111000
0001111111110000
0001111111100000
0000111111000000
0000111110000000
0000011100000000
0000000000000000
0000000000000000
0000000000000000
}

class Dog {
{sprite}$dog
}
@enduml
```

### 신호등 다이어그램
```
@startuml
binary "입력 신호" as I
state "처리 상태" as P
state "대기 상태" as W

[*] --> W
W --> P : 이벤트 발생
P --> W : 처리 완료
@enduml
```

## 생성형 AI와 통합

생성형 AI를 활용해 PlantUML 다이어그램을 생성하고 개선하는 방법.

### 자연어에서 다이어그램 생성

#### 예제 1: 마이크로서비스 아키텍처
입력:
```
"주문 관리, 재고 관리, 결제 처리, 배송 추적, 사용자 관리 기능을 가진 이커머스 마이크로서비스 아키텍처를 설계해주세요."
```

AI 생성 결과:
```
@startuml
!define ICONURL https://raw.githubusercontent.com/tupadr3/plantuml-icon-font-sprites/master/devicons
!includeurl ICONURL/java.puml
!includeurl ICONURL/nodejs.puml
!includeurl ICONURL/python.puml
!includeurl ICONURL/mongodb.puml
!includeurl ICONURL/postgresql.puml
!includeurl ICONURL/redis.puml

skinparam componentStyle rectangle

cloud "클라이언트" {
[모바일 앱]
[웹 앱]
}

node "API Gateway" {
[API 라우팅]
[인증/인가]
[부하 분산]
[캐싱]
}

node "서비스" {
frame "주문 서비스" <<java>> {
[주문 관리 API]
[주문 처리 로직]
database "주문 DB" <<postgresql>>
}

frame "재고 서비스" <<python>> {
[재고 관리 API]
[재고 처리 로직]
database "재고 DB" <<mongodb>>
}

frame "결제 서비스" <<nodejs>> {
[결제 API]
[결제 처리 로직]
[외부 결제 연동]
database "결제 DB" <<postgresql>>
}

frame "배송 서비스" <<java>> {
[배송 API]
[배송 추적 로직]
[외부 배송사 연동]
database "배송 DB" <<mongodb>>
}

frame "사용자 서비스" <<nodejs>> {
[사용자 API]
[인증 로직]
[프로필 관리]
database "사용자 DB" <<postgresql>>
}

database "캐시 저장소" <<redis>>
}

node "메시징" {
[이벤트 버스]
[메시지 큐]
}

node "모니터링 & 로깅" {
[로그 수집]
[메트릭 수집]
[알림]
database "로그 저장소"
}

' 클라이언트와 API Gateway 연결
[모바일 앱] --> [API 라우팅]
[웹 앱] --> [API 라우팅]

' API Gateway와 서비스 연결
[API 라우팅] --> [주문 관리 API]
[API 라우팅] --> [재고 관리 API]
[API 라우팅] --> [결제 API]
[API 라우팅] --> [배송 API]
[API 라우팅] --> [사용자 API]

' 서비스 간 연결
[주문 처리 로직] ..> [이벤트 버스] : 주문 생성됨
[재고 처리 로직] <.. [이벤트 버스] : 주문 생성됨
[결제 처리 로직] <.. [이벤트 버스] : 주문 생성됨
[배송 추적 로직] <.. [이벤트 버스] : 결제 완료됨

' 데이터베이스 연결
[주문 처리 로직] --> [주문 DB]
[재고 처리 로직] --> [재고 DB]
[결제 처리 로직] --> [결제 DB]
[배송 추적 로직] --> [배송 DB]
[사용자 API] --> [사용자 DB]

' 캐시 연결
[주문 관리 API] --> [캐시 저장소]
[재고 관리 API] --> [캐시 저장소]
[결제 API] --> [캐시 저장소]
[배송 API] --> [캐시 저장소]
[사용자 API] --> [캐시 저장소]

' 로깅 연결
[주문 관리 API] ..> [로그 수집] : 로그
[재고 관리 API] ..> [로그 수집] : 로그
[결제 API] ..> [로그 수집] : 로그
[배송 API] ..> [로그 수집] : 로그
[사용자 API] ..> [로그 수집] : 로그

@enduml
```

#### 예제 2: 상태 기계 다이어그램
입력:
```
"주문 처리 시스템의 상태 다이어그램을 만들어주세요. 상태는 생성됨, 결제 대기, 결제 완료, 배송 준비, 배송 중, 배송 완료, 취소됨이 있습니다. 각 상태 간의 전이 조건도 포함해주세요."
```

AI 생성 결과:
```
@startuml
skinparam state {
BackgroundColor LightBlue
BorderColor DarkBlue
ArrowColor DarkBlue

BackgroundColor<<Warning>> LightYellow
BorderColor<<Warning>> DarkGoldenRod

BackgroundColor<<Success>> LightGreen
BorderColor<<Success>> DarkGreen

BackgroundColor<<Danger>> Salmon
BorderColor<<Danger>> DarkRed
}

[*] --> 생성됨 : 주문 작성
생성됨 --> 결제대기 : 주문 확인
생성됨 --> 취소됨 : 사용자 취소
결제대기 --> 결제완료 : 결제 승인
결제대기 --> 취소됨 : 사용자 취소 / 결제 실패 / 결제 시간 초과
결제완료 --> 배송준비 : 주문 처리 시작
결제완료 --> 취소됨 : 재고 부족 / 관리자 취소
배송준비 --> 배송중 : 택배사 인계
배송준비 --> 취소됨 : 배송 불가 / 관리자 취소
배송중 --> 배송완료 : 배송 확인
배송중 --> 취소됨 : 배송 실패
배송완료 --> [*]
취소됨 --> [*]

state 생성됨
state 결제대기
state 결제완료 <<Success>>
state 배송준비
state 배송중 <<Warning>>
state 배송완료 <<Success>>
state 취소됨 <<Danger>>

note right of 생성됨
주문이 생성되었지만
아직 결제가 진행되지 않음
end note

note right of 결제대기
결제 진행 중,
시간 제한: 30분
end note

note right of 취소됨
주문이 취소된 상태.
재고는 원상복구되며
환불 프로세스가 시작됨.
end note
@enduml
```

### 코드에서 다이어그램 추출

다음은 간단한 typescript 클래스 코드를 기반으로 클래스 다이어그램을 생성하는 예제다.

#### typescript 코드:
```typescript
class User {
  private user_id: string;
  private name: string;
  private email: string;
  private orders: Order[] = [];

  constructor(user_id: string, name: string, email: string) {
    this.user_id = user_id;
    this.name = name;
    this.email = email;
  }

  public addOrder(order: Order): void {
    this.orders.push(order);
  }

  public getOrders(): Order[] {
    return this.orders;
  }
}

class Order {
  private order_id: string;
  private user: User;
  private items: OrderItem[];
  private total_amount: number;
  private status: string = "CREATED";

  constructor(order_id: string, user: User, items: OrderItem[], total_amount: number) {
    this.order_id = order_id;
    this.user = user;
    this.items = items;
    this.total_amount = total_amount;
  }

  public process(): void {
    this.status = "PROCESSING";
  }

  public ship(): void {
    this.status = "SHIPPED";
  }

  public deliver(): void {
    this.status = "DELIVERED";
  }

  public cancel(): void {
    this.status = "CANCELLED";
  }
}

class OrderItem {
  private product: Product;
  private quantity: number;
  private price: number;

  constructor(product: Product, quantity: number, price: number) {
    this.product = product;
    this.quantity = quantity;
    this.price = price;
  }

  public getSubtotal(): number {
    return this.quantity * this.price;
  }
}

class Product {
  private product_id: string;
  private name: string;
  private price: number;
  private stock: number;

  constructor(product_id: string, name: string, price: number, stock: number) {
    this.product_id = product_id;
    this.name = name;
    this.price = price;
    this.stock = stock;
  }

  public updateStock(quantity: number): void {
    this.stock += quantity;
  }
}
```

#### 생성된 PlantUML 다이어그램:
```
@startuml
class User {
  -user_id
  -name
  -email
  -orders: List[Order]
  +add_order(order: Order): void
  +get_orders(): List[Order]
}

class Order {
  -order_id
  -user: User
  -items: List[OrderItem]
  -total_amount
  -status: String
  +process(): void
  +ship(): void
  +deliver(): void
  +cancel(): void
}

class OrderItem {
  -product: Product
  -quantity: int
  -price: float
  +get_subtotal(): float
}

class Product {
  -product_id
  -name
  -price
  -stock
  +update_stock(quantity: int): void
}

User "1" --> "0..*" Order: has
Order "1" --> "1..*" OrderItem: contains
OrderItem "0..*" --> "1" Product: references
@enduml
```

### 다이어그램 개선 및 리팩토링

생성형 AI는 기존 다이어그램을 분석하고 개선하는 데 도움을 준다.

#### 개선 전 다이어그램:
```
@startuml
[클라이언트] --> [서버]
[서버] --> [데이터베이스]
@enduml
```

#### 개선 요청:
```
"이 시스템에 로드 밸런서, 캐싱 레이어, 마이크로서비스 아키텍처를 적용하여 개선해주세요."
```

#### 개선 후 다이어그램:
```
@startuml
skinparam componentStyle rectangle
skinparam monochrome true
skinparam shadowing false

cloud "외부" {
  [모바일 클라이언트]
  [웹 클라이언트]
}

node "인프라" {
  [CDN] as cdn
  [로드 밸런서] as lb
  
  node "서비스 계층" {
    [API 게이트웨이] as gateway
    
    package "마이크로서비스" {
      [사용자 서비스] as user_service
      [상품 서비스] as product_service
      [주문 서비스] as order_service
      [결제 서비스] as payment_service
    }
    
    [캐시 레이어] as cache
    
    database "데이터 계층" {
      [사용자 DB] as user_db
      [상품 DB] as product_db
      [주문 DB] as order_db
      [결제 DB] as payment_db
    }
  }
}

[모바일 클라이언트] --> cdn
[웹 클라이언트] --> cdn
cdn --> lb
lb --> gateway

gateway --> user_service
gateway --> product_service
gateway --> order_service
gateway --> payment_service

user_service --> cache
product_service --> cache
order_service --> cache
payment_service --> cache

cache --> user_db
cache --> product_db
cache --> order_db
cache --> payment_db

user_service --> user_db
product_service --> product_db
order_service --> order_db
payment_service --> payment_db

user_service <--> order_service : REST
product_service <--> order_service : REST
order_service <--> payment_service : REST
@enduml
```

## 팁과 모범 사례

### 다이어그램 복잡도 관리
1. **계층 구조 사용**: 복잡한 시스템은 여러 다이어그램으로 분리해 표현
2. **패키지 활용**: 관련 요소들을 패키지로 그룹화
3. **색상과 스타일링**: 중요한 요소를 시각적으로 구분
4. **노트 사용**: 복잡한 개념은 노트로 설명

### 일관성 유지
1. **명명 규칙**: 일관된 이름 지정 규칙 사용
2. **스타일 일관성**: 동일한 유형의 요소에 일관된 스타일 적용
3. **공통 요소 추출**: 반복되는 패턴은 매크로로 정의하여 재사용

### 가독성 향상
1. **적절한 레이아웃**: 요소 간 관계를 명확히 표현
2. **스페이싱**: 복잡한 다이어그램에 충분한 공간 확보
3. **간결한 텍스트**: 설명은 짧고 명확하게 작성

### 협업 및 버전 관리
1. **주석 사용**: 다른 사람이 이해할 수 있도록 주석 추가
2. **모듈화**: 재사용 가능한 다이어그램 구성 요소 만들기
3. **Git 통합**: PlantUML 파일을 Git으로 관리하여 버전 추적 및 협업 지원

### 생성형 AI 활용 최적화
1. **명확한 지시**: AI에게 다이어그램의 목적과 필요한 세부 사항을 구체적으로 설명
2. **반복적 개선**: 생성된 다이어그램을 점진적으로 개선
3. **요구사항 세분화**: 복잡한 다이어그램은 더 작은 부분으로 나누어 생성
4. **프롬프트 템플릿 활용**: 효과적인 프롬프트 패턴 재사용

## 생성형 AI와 통합하기 위한 프롬프트 템플릿

### 다이어그램 생성 템플릿
```
"다음 [시스템/프로세스/개념]에 대한 [다이어그램 유형] PlantUML 다이어그램을 생성:

요구사항:
1. [요구사항 1]
2. [요구사항 2]
...

포함해야 할 요소:
- [요소 1]
- [요소 2]
...

스타일 가이드라인:
- [스타일 가이드라인 1]
- [스타일 가이드라인 2]
..."
```

### 다이어그램 개선 템플릿
```
"다음 PlantUML 다이어그램을 개선:

```
[기존 다이어그램 코드]
```

개선 요청사항:
1. [개선 요청 1]
2. [개선 요청 2]
...

추가 고려사항:
- [고려사항 1]
- [고려사항 2]
..."
```

### 코드에서 다이어그램 추출 템플릿
```
"다음 [언어] 코드를 분석하여 [다이어그램 유형] PlantUML 다이어그램을 생성:

```
[소스 코드]
```

중점적으로 표현할 부분:
- [중점 1]
- [중점 2]
...

제외할 부분:
- [제외 1]
- [제외 2]# PlantUML + 생성형 AI 활용

## 목차
- [PlantUML 소개](#plantuml-소개)
- [기본 문법](#기본-문법)
- [다이어그램 유형](#다이어그램-유형)
    - [시퀀스 다이어그램](#시퀀스-다이어그램)
    - [클래스 다이어그램](#클래스-다이어그램)
    - [유스케이스 다이어그램](#유스케이스-다이어그램)
    - [활동 다이어그램](#활동-다이어그램)
    - [상태 다이어그램](#상태-다이어그램)
    - [컴포넌트 다이어그램](#컴포넌트-다이어그램)
    - [배포 다이어그램](#배포-다이어그램)
    - [객체 다이어그램](#객체-다이어그램)
    - [타이밍 다이어그램](#타이밍-다이어그램)
    - [ER 다이어그램](#er-다이어그램)
    - [네트워크 다이어그램](#네트워크-다이어그램)
    - [마인드맵](#마인드맵)
    - [WBS (Work Breakdown Structure)](#wbs-work-breakdown-structure)
    - [간트 차트](#간트-차트)
- [스타일링 및 테마](#스타일링-및-테마)
- [고급 기능](#고급-기능)
- [생성형 AI와 통합](#생성형-ai와-통합)
- [팁과 모범 사례](#팁과-모범-사례)

## PlantUML 소개

PlantUML은 텍스트 기반으로 UML(Unified Modeling Language) 다이어그램을 생성하는 오픈소스 도구다. 텍스트 형식으로 다이어그램을 정의해 버전 관리 시스템과 함께 사용하기 쉽고, 코드로서의 다이어그램(Diagram as Code) 개념을 구현한다.

### PlantUML의 장점
- 텍스트 기반으로 버전 관리 용이
- 다양한 UML 다이어그램 지원
- 커스터마이징 가능
- 다양한 통합 지원 (IDE, 위키, 문서 도구)
- 오픈 소스

## 기본 문법

모든 PlantUML 다이어그램은 다음 기본 구조를 따른다:

```
@startuml [파일명]
// 다이어그램 내용
@enduml
```

또는 특정 다이어그램을 명시적으로 지정할 수도 있다:

```
@startclass
// 클래스 다이어그램 내용
@endclass

@startsequence
// 시퀀스 다이어그램 내용
@endsequence
```

### 주석
```
' 이것은 한 줄 주석
/' 이것은
여러 줄
주석 '/
```

### 공통 스타일링 옵션
```
skinparam {
paramName value
}
```

## 다이어그램 유형

### 시퀀스 다이어그램

시퀀스 다이어그램은 객체 간의 상호작용을 시간 순서대로 표현한다.

#### 기본 예제
```
@startuml
actor 사용자
participant "첫 번째 클래스" as A
participant "두 번째 클래스" as B
participant "마지막 클래스" as C

사용자 -> A: 요청
activate A
A -> B: 위임
activate B
B -> C: 요청
activate C
C --> B: 응답
destroy C
B --> A: 응답
deactivate B
A --> 사용자: 응답
deactivate A
@enduml
```

#### 참가자 정의
```
actor 액터명
boundary 경계명
control 컨트롤명
entity 엔티티명
database 데이터베이스명
collections 컬렉션명
participant 참가자명
```

#### 메시지 유형
```
-> : 실선 화살표
--> : 점선 화살표
->> : 열린 화살표
->x : 손실 메시지
->o : 발견 메시지
<-> : 양방향 메시지
```

#### 활성화 및 비활성화
```
activate A
deactivate A
destroy A
```

#### 그룹화
```
alt 조건
// 메시지
else 다른 조건
// 메시지
end

loop 반복 조건
// 메시지
end

par 병렬 처리
// 메시지
and
// 메시지
end
```

#### 노트
```
note left of A: 왼쪽 노트
note right of A: 오른쪽 노트
note over A,B: 여러 참가자에 걸친 노트
```

### 클래스 다이어그램

클래스 다이어그램은 시스템의 클래스, 속성, 메서드 및 관계를 표현한다.

#### 기본 예제
```
@startuml
class Animal {
+name: String
+age: int
+makeSound(): void
-privateMethod(): void
}

class Dog {
+breed: String
+fetch(): void
}

class Cat {
+color: String
+climb(): void
}

Animal <|-- Dog
Animal <|-- Cat
@enduml
```

#### 접근 제한자
```
+ : 공개(public)
- : 비공개(private)
# : 보호(protected)
~ : 패키지(package/default)
```

#### 관계 유형
```
<|-- : 상속/일반화
*-- : 컴포지션
o-- : 집합
<-- : 연관
<.. : 의존
..|> : 인터페이스 구현
-- : 양방향 연관
```

#### 관계에 설명 추가
```
A "1" -- "n" B : contains
```

#### 추상 클래스 및 인터페이스
```
abstract class AbstractClass
interface Interface
```

#### 패키지
```
package "패키지명" {
// 클래스들
}
```

#### 스테레오타입
```
class User << (S,#FF7700) Singleton >>
```

### 유스케이스 다이어그램

유스케이스 다이어그램은 사용자와 시스템 간의 상호작용을 표현한다.

#### 기본 예제
```
@startuml
left to right direction
actor 고객
actor 판매자
rectangle 쇼핑시스템 {
usecase "상품 검색" as UC1
usecase "장바구니 관리" as UC2
usecase "주문하기" as UC3
usecase "결제하기" as UC4
}

고객 --> UC1
고객 --> UC2
고객 --> UC3
고객 --> UC4
UC3 ..> UC4 : <<include>>
판매자 --> UC4
@enduml
```

#### 관계 유형
```
--> : 연관
..> : 의존
.> : 확장 (<<extend>>)
.> : 포함 (<<include>>)
-|> : 일반화
```

#### 노트
```
note left of UC1 : 이것은 노트
```

### 활동 다이어그램

활동 다이어그램은 프로세스나 알고리즘의 흐름을 표현한다.

#### 기본 예제
```
@startuml
start
:사용자 로그인;
if (인증 성공?) then (yes)
:대시보드 표시;
:작업 수행;
else (no)
:에러 메시지 표시;
:로그인 페이지;
endif
:로그아웃;
stop
@enduml
```

#### 액티비티
```
:액티비티 텍스트;
```

#### 분기
```
if (조건) then (yes)
// 작업
else (no)
// 작업
endif
```

#### 반복
```
while (조건)
// 작업
endwhile

repeat
// 작업
repeat while (조건)
```

#### 병렬 처리
```
fork
// 병렬 작업 1
fork again
// 병렬 작업 2
end fork
```

#### 파티션
```
partition "파티션 이름" {
// 액티비티
}
```

#### 스윔레인
```
|스윔레인1|
:액티비티1;
|스윔레인2|
:액티비티2;
```

### 상태 다이어그램

상태 다이어그램은 객체의 상태 변화와 이벤트를 표현한다.

#### 기본 예제
```
@startuml
[*] --> 초기상태
초기상태 --> 처리중 : 시작
처리중 --> 완료 : 처리 완료
처리중 --> 에러 : 오류 발생
에러 --> 처리중 : 재시도
완료 --> [*]
@enduml
```

#### 상태
```
state "상태 이름" as 상태ID
```

#### 복합 상태
```
state 상위상태 {
[*] --> 하위상태1
하위상태1 --> 하위상태2
하위상태2 --> [*]
}
```

#### 노트
```
note left of 상태 : 노트 내용
```

#### 히스토리
```
상태1 --> H : 이벤트
H --> 상태2
```

### 컴포넌트 다이어그램

컴포넌트 다이어그램은 시스템의 구성 요소와 그들 간의 의존성을 표현한다.

#### 기본 예제
```
@startuml
package "프론트엔드" {
[웹 클라이언트]
}

package "백엔드" {
[API 서버]
[인증 서비스]
[결제 처리]
database "사용자 DB"
database "주문 DB"
}

[웹 클라이언트] --> [API 서버]
[API 서버] --> [인증 서비스]
[API 서버] --> [결제 처리]
[인증 서비스] --> [사용자 DB]
[API 서버] --> [주문 DB]
@enduml
```

#### 컴포넌트 표현
```
[컴포넌트명]
component [컴포넌트명]
```

#### 인터페이스
```
() "인터페이스명"
```

#### 포트
```
[컴포넌트] #-- ()
```

### 배포 다이어그램

배포 다이어그램은 하드웨어 및 소프트웨어 컴포넌트의 물리적 배치를 표현한다.

#### 기본 예제
```
@startuml
cloud "클라우드" {
node "웹 서버" {
[프론트엔드 앱]
}

node "애플리케이션 서버" {
[백엔드 API]
}

database "데이터베이스 서버" {
[SQL DB]
}
}

node "클라이언트 기기" {
[웹 브라우저]
}

[웹 브라우저] --> [프론트엔드 앱]
[프론트엔드 앱] --> [백엔드 API]
[백엔드 API] --> [SQL DB]
@enduml
```

#### 노드 표현
```
node 노드명
```

#### 아티팩트
```
artifact 아티팩트명
```

#### 네트워크
```
cloud 클라우드명
```

### 객체 다이어그램

객체 다이어그램은 클래스의 인스턴스와 그들 간의 관계를 표현한다.

#### 기본 예제
```
@startuml
object 고객1 {
이름 = "홍길동"
이메일 = "hong@example.com"
}

object 주문1 {
주문번호 = "ORD-12345"
금액 = 50000
}

object 상품1 {
상품명 = "스마트폰"
가격 = 50000
}

고객1 --> 주문1 : 주문함
주문1 o--> 상품1 : 포함함
@enduml
```

#### 객체 표현
```
object 객체명
```

#### 맵 표현
```
map 맵명 {
key1 => value1
key2 => value2
}
```

### 타이밍 다이어그램

타이밍 다이어그램은 시간 경과에 따른 상태 변화를 표현한다.

#### 기본 예제
```
@startuml
robust "웹 서버" as WEB
robust "데이터베이스" as DB
concise "사용자" as USER

@0
USER is 대기
WEB is 유휴
DB is 유휴

@+1
USER -> WEB : 요청
USER is 요청중
WEB is 처리중

@+1
WEB -> DB : 쿼리
WEB is 대기
DB is 처리중

@+1
DB is 응답
DB -> WEB : 결과
WEB is 처리중

@+1
WEB -> USER : 응답
WEB is 유휴
DB is 유휴
USER is 대기
@enduml
```

#### 타이밍 표현
```
@시간
객체 is 상태
객체1 -> 객체2 : 메시지
```

### ER 다이어그램

ER(Entity-Relationship) 다이어그램은 데이터베이스의 구조를 표현한다.

#### 기본 예제
```
@startuml
entity 고객 {
* 고객ID : number <<PK>>
  --
* 이름 : string
* 이메일 : string
  주소 : string
  생성일 : date
  }

entity 주문 {
* 주문ID : number <<PK>>
  --
* 고객ID : number <<FK>>
  주문일 : date
  총액 : number
  }

entity 상품 {
* 상품ID : number <<PK>>
  --
* 상품명 : string
  가격 : number
  재고 : number
  }

entity 주문상세 {
* 주문ID : number <<PK, FK>>
* 상품ID : number <<PK, FK>>
  --
  수량 : number
  단가 : number
  }

고객 ||--o{ 주문
주문 ||--|{ 주문상세
상품 }|--|| 주문상세
@enduml
```

#### 엔티티 표현
```
entity 엔티티명 {
* 필수속성 : 타입 <<제약조건>>
  선택속성 : 타입
  --
* 다른속성 : 타입
  }
```

#### 관계 표현
```
|o--o| : 일대일 (선택적)
||--|| : 일대일 (필수적)
|o--|| : 일대일 (한쪽은 선택적)
||--o{ : 일대다 (다쪽은 선택적)
||--|{ : 일대다 (필수적)
}|--|| : 다대일
}o--o{ : 다대다
```

### 네트워크 다이어그램

네트워크 다이어그램은 네트워크 토폴로지를 표현한다.

#### 기본 예제
```
@startuml
nwdiag {
network 인터넷 {
라우터 [address = "외부 IP"];
}

network 내부망 {
address = "192.168.1.0/24"
라우터 [address = "192.168.1.1"];
웹서버 [address = "192.168.1.10"];
DB서버 [address = "192.168.1.20"];
}

network DMZ {
address = "192.168.2.0/24"
라우터 [address = "192.168.2.1"];
프록시 [address = "192.168.2.10"];
}
}
@enduml
```

#### 네트워크 정의
```
network 네트워크명 {
address = "주소"
장비 [address = "IP"];
}
```

### 마인드맵

마인드맵은 아이디어나 개념 간의 관계를 시각적으로 표현한다.

#### 기본 예제
```
@startmindmap
* 프로젝트 계획
  ** 요구사항 분석
  *** 사용자 인터뷰
  *** 시장 조사
  ** 설계
  *** UI/UX 설계
  *** 데이터베이스 설계
  *** API 설계
  ** 개발
  *** 프론트엔드
  **** React
  **** CSS
  *** 백엔드
  **** API 서버
  **** 데이터베이스
  ** 테스트
  *** 단위 테스트
  *** 통합 테스트
  *** UI 테스트
  ** 배포
  *** CI/CD 구성
  *** 인프라 구축
  @endmindmap
```

#### 방향 지정
```
@startmindmap
<style>
mindmapDiagram {
  .green {
    BackgroundColor lightgreen
  }
  .rose {
    BackgroundColor #FFBBCC
  }
}
</style>
* 루트 <<green>>
  ** 오른쪽 1 <<rose>>
  ** 오른쪽 2
  left side
  ** 왼쪽 1
  ** 왼쪽 2
  @endmindmap
```

### WBS (Work Breakdown Structure)

WBS는 프로젝트 작업 분해도를 표현한다.

#### 기본 예제
```
@startwbs
* 프로젝트
  ** 기획
  *** 요구사항 분석
  *** 기능 명세
  ** 설계
  *** 아키텍처 설계
  *** UI/UX 설계
  ** 개발
  *** 프론트엔드 개발
  **** 컴포넌트 구현
  **** 상태 관리
  *** 백엔드 개발
  **** API 구현
  **** 데이터베이스 연동
  ** 테스트
  *** 단위 테스트
  *** 통합 테스트
  ** 배포
  *** 스테이징 배포
  *** 프로덕션 배포
  @endwbs
```

### 간트 차트

간트 차트는 프로젝트 일정을 표현한다.

#### 기본 예제
```
@startgantt
project starts the 2023/01/01
[요구사항 분석] lasts 10 days
[설계] lasts 15 days
[설계] starts at [요구사항 분석]'s end
[개발] lasts 30 days
[개발] starts at [설계]'s end
[테스트] lasts 15 days
[테스트] starts at [개발]'s end
[배포] lasts 5 days
[배포] starts at [테스트]'s end
@endgantt
```

#### 작업 정의
```
[작업명] lasts X days
[작업명] starts YYYY/MM/DD
[작업명] ends YYYY/MM/DD
```

#### 마일스톤
```
[마일스톤] happens YYYY/MM/DD
[마일스톤] happens at [작업]'s end
```

#### 의존성
```
[작업2] starts at [작업1]'s end
```

## 스타일링 및 테마

### 기본 스타일링
```
@startuml
skinparam backgroundColor #EEEBDC
skinparam handwritten true

skinparam sequence {
ArrowColor DeepSkyBlue
ActorBorderColor DeepSkyBlue
LifeLineBorderColor blue
LifeLineBackgroundColor #A9DCDF

ParticipantBorderColor DeepSkyBlue
ParticipantBackgroundColor DodgerBlue
ParticipantFontName Impact
ParticipantFontSize 17
ParticipantFontColor #A9DCDF

ActorBackgroundColor aqua
ActorFontColor DeepSkyBlue
ActorFontSize 17
ActorFontName Aapex
}

actor User
participant "First Class" as A
participant "Second Class" as B
participant "Last Class" as C

User -> A: DoWork
activate A
A -> B: Create Request
activate B
B -> C: DoWork
activate C
C --> B: WorkDone
destroy C
B --> A: Request Created
deactivate B
A --> User: Done
deactivate A
@enduml
```

### 내장 테마 사용
```
@startuml
!theme cerulean
// 다이어그램 내용
@enduml
```

사용 가능한 내장 테마:
- amiga
- aws-orange
- black-knight
- cerulean
- crt-amber
- crt-green
- cyborg
- hacker
- materia
- minty
- sketchy
- superhero
- toy

### 사용자 정의 테마
```
@startuml
!theme black-knight

!define PRIMARY #8be9fd
!define SECONDARY #bd93f9
!define SUCCESS #50fa7b
!define INFO #f1fa8c
!define WARNING #ffb86c
!define DANGER #ff5555

skinparam backgroundColor #282a36
skinparam BorderColor white

skinparam ClassAttributeFontColor #f8f8f2
skinparam ClassBackgroundColor #44475a
skinparam ClassBorderColor #f8f8f2

// 다이어그램 내용
@enduml
```

## 고급 기능

### 다이어그램 포함
```
@startuml
!include path/to/other.puml
!includesub path/to/other.puml!SUBPART
@enduml
```

### 매크로 정의
```
!definelong CUSTOM_ELEMENT
class Example {
+standard_fields
+custom_method()
}
!enddefinelong

CUSTOM_ELEMENT
```

### 변수 사용
```
!$color = "red"
!$name = "Product"

class $name {
+id: int
}

skinparam class {
BackgroundColor $color
}
```

### 조건부 프리프로세싱
```
!if (%not(%variable_exists("$BGCOLOR")))
!$BGCOLOR = "white"
!endif

skinparam backgroundColor $BGCOLOR
```

### 스프라이트 사용
```
@startuml
sprite $dog [15x15/8] {
0000000000000000
0000000000000000
0011111111111000
0111111111111100
0111111111111100
0111111111111100
0111111111111100
0011111111111000
0001111111110000
0001111111100000
0000111111000000
0000111110000000
0000011100000000
0000000000000000
0000000000000000
0000000000000000
}

class Dog {
{sprite}$dog
}
@enduml
```

### 신호등 다이어그램
```
@startuml
binary "입력 신호" as I
state "처리 상태" as P
state "대기 상태" as W

[*] --> W
W --> P : 이벤트 발생
P --> W : 처리 완료
@enduml
```

## 생성형 AI와 통합

생성형 AI를 활용해 PlantUML 다이어그램을 생성하고 개선하는 방법.

### 자연어에서 다이어그램 생성

#### 예제 1: 마이크로서비스 아키텍처
입력:
```
"주문 관리, 재고 관리, 결제 처리, 배송 추적, 사용자 관리 기능을 가진 이커머스 마이크로서비스 아키텍처를 설계해주세요."
```

AI 생성 결과:
```
@startuml
!define ICONURL https://raw.githubusercontent.com/tupadr3/plantuml-icon-font-sprites/master/devicons
!includeurl ICONURL/java.puml
!includeurl ICONURL/nodejs.puml
!includeurl ICONURL/python.puml
!includeurl ICONURL/mongodb.puml
!includeurl ICONURL/postgresql.puml
!includeurl ICONURL/redis.puml

skinparam componentStyle rectangle

cloud "클라이언트" {
[모바일 앱]
[웹 앱]
}

node "API Gateway" {
[API 라우팅]
[인증/인가]
[부하 분산]
[캐싱]
}

node "서비스" {
frame "주문 서비스" <<java>> {
[주문 관리 API]
[주문 처리 로직]
database "주문 DB" <<postgresql>>
}

frame "재고 서비스" <<python>> {
[재고 관리 API]
[재고 처리 로직]
database "재고 DB" <<mongodb>>
}

frame "결제 서비스" <<nodejs>> {
[결제 API]
[결제 처리 로직]
[외부 결제 연동]
database "결제 DB" <<postgresql>>
}

frame "배송 서비스" <<java>> {
[배송 API]
[배송 추적 로직]
[외부 배송사 연동]
database "배송 DB" <<mongodb>>
}

frame "사용자 서비스" <<nodejs>> {
[사용자 API]
[인증 로직]
[프로필 관리]
database "사용자 DB" <<postgresql>>
}

database "캐시 저장소" <<redis>>
}

node "메시징" {
[이벤트 버스]
[메시지 큐]
}

node "모니터링 & 로깅" {
[로그 수집]
[메트릭 수집]
[알림]
database "로그 저장소"
}

' 클라이언트와 API Gateway 연결
[모바일 앱] --> [API 라우팅]
[웹 앱] --> [API 라우팅]

' API Gateway와 서비스 연결
[API 라우팅] --> [주문 관리 API]
[API 라우팅] --> [재고 관리 API]
[API 라우팅] --> [결제 API]
[API 라우팅] --> [배송 API]
[API 라우팅] --> [사용자 API]

' 서비스 간 연결
[주문 처리 로직] ..> [이벤트 버스] : 주문 생성됨
[재고 처리 로직] <.. [이벤트 버스] : 주문 생성됨
[결제 처리 로직] <.. [이벤트 버스] : 주문 생성됨
[배송 추적 로직] <.. [이벤트 버스] : 결제 완료됨

' 데이터베이스 연결
[주문 처리 로직] --> [주문 DB]
[재고 처리 로직] --> [재고 DB]
[결제 처리 로직] --> [결제 DB]
[배송 추적 로직] --> [배송 DB]
[사용자 API] --> [사용자 DB]

' 캐시 연결
[주문 관리 API] --> [캐시 저장소]
[재고 관리 API] --> [캐시 저장소]
[결제 API] --> [캐시 저장소]
[배송 API] --> [캐시 저장소]
[사용자 API] --> [캐시 저장소]

' 로깅 연결
[주문 관리 API] ..> [로그 수집] : 로그
[재고 관리 API] ..> [로그 수집] : 로그
[결제 API] ..> [로그 수집] : 로그
[배송 API] ..> [로그 수집] : 로그
[사용자 API] ..> [로그 수집] : 로그

@enduml
```

#### 예제 2: 상태 기계 다이어그램
입력:
```
"주문 처리 시스템의 상태 다이어그램을 만들어주세요. 상태는 생성됨, 결제 대기, 결제 완료, 배송 준비, 배송 중, 배송 완료, 취소됨이 있습니다. 각 상태 간의 전이 조건도 포함해주세요."
```

AI 생성 결과:
```
@startuml
skinparam state {
BackgroundColor LightBlue
BorderColor DarkBlue
ArrowColor DarkBlue

BackgroundColor<<Warning>> LightYellow
BorderColor<<Warning>> DarkGoldenRod

BackgroundColor<<Success>> LightGreen
BorderColor<<Success>> DarkGreen

BackgroundColor<<Danger>> Salmon
BorderColor<<Danger>> DarkRed
}

[*] --> 생성됨 : 주문 작성
생성됨 --> 결제대기 : 주문 확인
생성됨 --> 취소됨 : 사용자 취소
결제대기 --> 결제완료 : 결제 승인
결제대기 --> 취소됨 : 사용자 취소 / 결제 실패 / 결제 시간 초과
결제완료 --> 배송준비 : 주문 처리 시작
결제완료 --> 취소됨 : 재고 부족 / 관리자 취소
배송준비 --> 배송중 : 택배사 인계
배송준비 --> 취소됨 : 배송 불가 / 관리자 취소
배송중 --> 배송완료 : 배송 확인
배송중 --> 취소됨 : 배송 실패
배송완료 --> [*]
취소됨 --> [*]

state 생성됨
state 결제대기
state 결제완료 <<Success>>
state 배송준비
state 배송중 <<Warning>>
state 배송완료 <<Success>>
state 취소됨 <<Danger>>

note right of 생성됨
주문이 생성되었지만
아직 결제가 진행되지 않음
end note

note right of 결제대기
결제 진행 중,
시간 제한: 30분
end note

note right of 취소됨
주문이 취소된 상태.
재고는 원상복구되며
환불 프로세스가 시작됨.
end note
@enduml
```

### 코드에서 다이어그램 추출

다음은 간단한 typescript 클래스 코드를 기반으로 클래스 다이어그램을 생성하는 예제다.

#### typescript 코드:
```typescript
class User {
  private user_id: string;
  private name: string;
  private email: string;
  private orders: Order[] = [];

  constructor(user_id: string, name: string, email: string) {
    this.user_id = user_id;
    this.name = name;
    this.email = email;
  }

  public addOrder(order: Order): void {
    this.orders.push(order);
  }

  public getOrders(): Order[] {
    return this.orders;
  }
}

class Order {
  private order_id: string;
  private user: User;
  private items: OrderItem[];
  private total_amount: number;
  private status: string = "CREATED";

  constructor(order_id: string, user: User, items: OrderItem[], total_amount: number) {
    this.order_id = order_id;
    this.user = user;
    this.items = items;
    this.total_amount = total_amount;
  }

  public process(): void {
    this.status = "PROCESSING";
  }

  public ship(): void {
    this.status = "SHIPPED";
  }

  public deliver(): void {
    this.status = "DELIVERED";
  }

  public cancel(): void {
    this.status = "CANCELLED";
  }
}

class OrderItem {
  private product: Product;
  private quantity: number;
  private price: number;

  constructor(product: Product, quantity: number, price: number) {
    this.product = product;
    this.quantity = quantity;
    this.price = price;
  }

  public getSubtotal(): number {
    return this.quantity * this.price;
  }
}

class Product {
  private product_id: string;
  private name: string;
  private price: number;
  private stock: number;

  constructor(product_id: string, name: string, price: number, stock: number) {
    this.product_id = product_id;
    this.name = name;
    this.price = price;
    this.stock = stock;
  }

  public updateStock(quantity: number): void {
    this.stock += quantity;
  }
}
```

#### 생성된 PlantUML 다이어그램:
```
@startuml
class User {
  -user_id
  -name
  -email
  -orders: List[Order]
  +add_order(order: Order): void
  +get_orders(): List[Order]
}

class Order {
  -order_id
  -user: User
  -items: List[OrderItem]
  -total_amount
  -status: String
  +process(): void
  +ship(): void
  +deliver(): void
  +cancel(): void
}

class OrderItem {
  -product: Product
  -quantity: int
  -price: float
  +get_subtotal(): float
}

class Product {
  -product_id
  -name
  -price
  -stock
  +update_stock(quantity: int): void
}

User "1" --> "0..*" Order: has
Order "1" --> "1..*" OrderItem: contains
OrderItem "0..*" --> "1" Product: references
@enduml
```

### 다이어그램 개선 및 리팩토링

생성형 AI는 기존 다이어그램을 분석하고 개선하는 데 도움을 준다.

#### 개선 전 다이어그램:
```
@startuml
[클라이언트] --> [서버]
[서버] --> [데이터베이스]
@enduml
```

#### 개선 요청:
```
"이 시스템에 로드 밸런서, 캐싱 레이어, 마이크로서비스 아키텍처를 적용하여 개선해주세요."
```

#### 개선 후 다이어그램:
```
@startuml
skinparam componentStyle rectangle
skinparam monochrome true
skinparam shadowing false

cloud "외부" {
  [모바일 클라이언트]
  [웹 클라이언트]
}

node "인프라" {
  [CDN] as cdn
  [로드 밸런서] as lb
  
  node "서비스 계층" {
    [API 게이트웨이] as gateway
    
    package "마이크로서비스" {
      [사용자 서비스] as user_service
      [상품 서비스] as product_service
      [주문 서비스] as order_service
      [결제 서비스] as payment_service
    }
    
    [캐시 레이어] as cache
    
    database "데이터 계층" {
      [사용자 DB] as user_db
      [상품 DB] as product_db
      [주문 DB] as order_db
      [결제 DB] as payment_db
    }
  }
}

[모바일 클라이언트] --> cdn
[웹 클라이언트] --> cdn
cdn --> lb
lb --> gateway

gateway --> user_service
gateway --> product_service
gateway --> order_service
gateway --> payment_service

user_service --> cache
product_service --> cache
order_service --> cache
payment_service --> cache

cache --> user_db
cache --> product_db
cache --> order_db
cache --> payment_db

user_service --> user_db
product_service --> product_db
order_service --> order_db
payment_service --> payment_db

user_service <--> order_service : REST
product_service <--> order_service : REST
order_service <--> payment_service : REST
@enduml
```

## 팁과 모범 사례

### 다이어그램 복잡도 관리
1. **계층 구조 사용**: 복잡한 시스템은 여러 다이어그램으로 분리해 표현
2. **패키지 활용**: 관련 요소들을 패키지로 그룹화
3. **색상과 스타일링**: 중요한 요소를 시각적으로 구분
4. **노트 사용**: 복잡한 개념은 노트로 설명

### 일관성 유지
1. **명명 규칙**: 일관된 이름 지정 규칙 사용
2. **스타일 일관성**: 동일한 유형의 요소에 일관된 스타일 적용
3. **공통 요소 추출**: 반복되는 패턴은 매크로로 정의하여 재사용

### 가독성 향상
1. **적절한 레이아웃**: 요소 간 관계를 명확히 표현
2. **스페이싱**: 복잡한 다이어그램에 충분한 공간 확보
3. **간결한 텍스트**: 설명은 짧고 명확하게 작성

### 협업 및 버전 관리
1. **주석 사용**: 다른 사람이 이해할 수 있도록 주석 추가
2. **모듈화**: 재사용 가능한 다이어그램 구성 요소 만들기
3. **Git 통합**: PlantUML 파일을 Git으로 관리하여 버전 추적 및 협업 지원

### 생성형 AI 활용 최적화
1. **명확한 지시**: AI에게 다이어그램의 목적과 필요한 세부 사항을 구체적으로 설명
2. **반복적 개선**: 생성된 다이어그램을 점진적으로 개선
3. **요구사항 세분화**: 복잡한 다이어그램은 더 작은 부분으로 나누어 생성
4. **프롬프트 템플릿 활용**: 효과적인 프롬프트 패턴 재사용

`