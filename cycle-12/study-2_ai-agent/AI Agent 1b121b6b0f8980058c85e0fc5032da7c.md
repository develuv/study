# AI Agent

## AI Agent 란 무엇인가?

**Agent**는 단순한 언어 모델(LM)을 넘어서 외부 세계와 **도구를 통해 상호작용**하고, **자율적으로 목표를 수행**할 수 있는 **AI 시스템**입니다.

> **Model (Chat-Gpt)**
요청에 대한 1Way(번역하고 요약해서) 응답

**Agent**
사람의 간섭없이 자기 스스로 여러 단계들을 거치면서 생각을 하고 그거에 맞는 결정을 내리면서 결과물을 도출 해냄
> 
> 
> Agents are autonomous and can act independently of human intervention,
> especially when provided with proper goals or objectives they are meant to achieve.
> (사람의 간섭없이 독립적으로 스스로 판단…결정, 결과)
> 

ChatGPT 왈 : 

- **정의**: AI Agent는 단순한 질문-응답 시스템을 넘어, **목표를 설정하고 계획하며 도구를 활용해 문제를 해결하는 자율적 인공지능 시스템**입니다.
- **기본 특징**:
    - 입력을 받아 reasoning (추론)을 수행하고,
    - 필요시 도구를 사용하여 행동(action)을 수행하며,
    - 결과를 관찰하고 반복적인 판단을 통해 최종 목표를 달성합니다.

우리가 오늘 알아 볼것은 Agent라는 애가 어떻게 작동이 되는지 섹션단위로 알아 보자고~

![스크린샷 2025-03-10 오후 11.04.29.png](AI%20Agent%201b121b6b0f8980058c85e0fc5032da7c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-03-10_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.04.29.png)

**Agent Architecture 주요 흐름**

유저가 쿼리를 한번 날리면

오케스트레이션(Agent의 구조) 에 의해서 사용자가 기존에 작성해 놓은 prompt나 instructions이 있으면 

거기에 따라서 생각(판단 → 결정 → 판단 → 결정 → 결과)을 한다.

그 과정에서 단기기억 또는 장기기억 또는 RAG 챗봇 처럼 이전에 했던 대화 내용들 활용하고,

모델에 맞게 계획을 세우고 논리를 세워서 대답을 하게 된다.

중간중간에 외부 결정을 내려서 api calling을 해야 한다면 (예시, 항공편 숙박을 예약해줘 라고 한다면 구글 flighting API 연동) Tools를 통해서 처리한다.

모든 값들을 가중치를 결정해서 답변을 만들어 내는게 LLM Model 들을 활용해서 이렇게 3가지를 활용해서 전체 Agent가 돌아감

## 기본 구성 요소

| **구성 요소** | **설명** |
| --- | --- |
| **Goal / Task** | 에이전트가 달성해야 할 목표 (예: “회사 문서에서 이슈 요약해줘”) |
| **Memory** | 과거 대화, 행동, 관찰 정보를 저장해 장기적인 맥락을 유지 |
| **Reasoning (Planning)** | 목표를 달성하기 위해 무엇을 해야 할지 스스로 판단함 |
| **Action (Tool 사용)** | 외부 도구/API를 호출해 정보를 수집하거나 행동을 실행 |
| **Observation** | 행동 결과를 보고 다시 판단을 이어나감 |
| **Language Model** | 사고, 판단, 프롬프트 생성 등을 담당하는 핵심 추론 엔진 (예: GPT, Claude 등) |

### The Model

오케스트레이션 레이어에서 생각을 할수 있는 방법도 다양하게 있는데 

그게 바로 ReAct, Chain-of-Thought, or Tree-of-Thoughts 가 있다.

- 언어 모델(LM)로, Agent의 중심 추론 엔진 역할
- ReAct, CoT, ToT 등 추론 프레임워크를 따를 수 있음

### The Tools

기초 언어 모델(Foundation Model)은 텍스트 생성이나 이미지 생성에는 뛰어나지만, **외부 세계와 직접 상호작용하지는 못한다.**
Tools는 이 한계를 극복하는 **브릿지 역할**
에이전트가 **외부 데이터나 서비스와 연결**되어 **더 넓은 범위의 작업을 수행**할 수 있게 해준다.

| **구분** | **설명** |
| --- | --- |
| **기능** | 웹 API를 호출하여 정보를 얻거나 변경(조회, 생성, 수정, 삭제) |
| **API 메서드와 유사** | GET, POST, PATCH, DELETE 같은 HTTP 메서드를 사용하는 구조 |
| **예시 1** | 고객 정보 수정 → DB에 PATCH 요청 |
| **예시 2** | 날씨 데이터 수집 → 사용자에게 여행 추천 제공 시 반영 |

**Tools가 왜 중요한가?**

•	도구를 통해 **에이전트는 실시간 외부 정보를 활용**할 수 있고, 이를 통해 더 풍부하고 실용적인 응답을 제공할 수 있습니다.

•	단순한 언어 생성 모델을 **실행 가능한 시스템 수준으로 확장**하게 해줍니다.

•	**RAG (Retrieval-Augmented Generation)** 시스템과 같이,

•	문서나 데이터베이스에서 정보를 검색해

•	언어 모델의 답변에 실시간으로 반영하는 방식에도 도구가 핵심 역할

---

**🧩 핵심 요약**

•	**Tools는 에이전트가 외부 세계와 상호작용하도록 도와주는 기능**입니다.

•	이는 **에이전트의 내부 추론 능력과 실제 세계의 데이터 간의 연결고리** 역할을 합니다.

•	도구가 없으면 에이전트는 **자신이 학습한 지식에만 기반한 응답만 가능**합니다.

•	도구가 있으면 **실시간 정보 접근, 액션 실행, 서비스 호출**이 가능해집니다.

---

**🔍 예시 이미지 비유**

[언어 모델] <---- Tools (브릿지) ----> [날씨 API, 고객정보 DB, 이메일 서비스 등 외부 세계]

### **오케스트레이션 계층 (Orchestration Layer)**

- 입력 → 추론 → 액션 결정 → 실행 → 반복 또는 종료 의 사이클을 관리
- 멀티턴 대화와 연속된 논리 흐름 유지

### Agent vs Model 차이

| **항목** | **모델 (Model)** | **에이전트 (Agent)** |
| --- | --- | --- |
| 지식 | 학습 데이터에 한정 | 도구를 통해 확장 |
| 문맥 | 단일 응답 | 멀티턴 응답, 상태 유지 |
| 도구 사용 | 미지원 | 네이티브 도구 통합 |
| 추론 구조 | 프롬프트 기반 | CoT, ReAct 등 내장 아키텍처 |

## How Agents operate

에이전트 인지 아키텍처의 핵심에는 메모리, 상태, 추론 및 계획을 유지하는 오케스트레이션 계층이 있음, 

빠르게 진화하는 프롬프트 엔지니어링 분야와 관련 프레임워크를 사용하여 추론 및 계획을 안내하고, 에이전트가 환경과 보다 효과적으로 상호 작용하고 작업을 완료할 수 있도록 한다. 

프롬프트 엔지니어링 프레임워크 및 언어 모델에 대한 작업 계획 분야의 연구는 빠르게 진화하고 있으며, 다양한 유망한 접근 방식을 제공한다. 

아래 소개 하는 3가지는 현재 가장 인기 있는 프레임워크 및 추론 기술 일걸? (May be.. ㅋ)

### ReAct란?

**ReAct**는 **Reasoning + Acting**의 줄임말입니다.

대형 언어 모델(LLM, 예: GPT-4)이 스스로 생각(Reasoning)하고,

그 생각에 따라 행동(Action)하도록 유도하는 프롬프트 설계 기법(prompting framework)

### **ReAct가 등장한 이유**

기존의 언어 모델은 단순히 질문을 받으면 곧바로 답변만 하는 방식

하지만 실제 문제 해결은 보통 아래와 같은 흐름이 필요:

1.	문제를 이해하고,

2.	필요한 정보를 찾고,

3.	분석하거나 계산하고,

4.	최종적인 답을 도출함.

ReAct는 이런 **사고의 흐름과 행동 과정을 명시적으로 모델에게 시켜주는 방법**

### **ReAct의 구성 요소**

ReAct는 다음의 3가지 핵심 단계를 반복하며 문제를 해결

1.	**Thought (생각)**

• 문제를 분석하고, 다음에 무엇을 해야 할지 결정함.

• 예: “기차 시간표를 확인해야겠어.”

2.	**Action (행동)**

• 실제로 외부 도구를 사용하거나, 검색하거나, 계산함.

• 예: “유로스타 기차 시간 검색”

3.	**Observation (관찰)**

• 행동의 결과를 확인하고, 다음 행동을 계획함.

• 예: “기차는 2시간 20분이 걸린다.”

→ 이 과정을 반복하며, 최종적으로 Answer (답변)을 제공

### **ReAct 예시**

Q: 런던에서 파리까지 가장 빠르게 가는 방법은?

Thought: 비행기와 기차를 비교해야 해. 유로스타가 빠를 수도 있어.
Action: 유로스타 기차 소요 시간 검색
Observation: 유로스타는 약 2시간 20분이 걸린다.
Thought: 비행기는 공항 이동 시간 포함하면 더 오래 걸릴 수 있어.
Answer: 유로스타 기차가 런던에서 파리까지 가장 빠른 방법입니다.

→ AI가 마치 **사람처럼 생각하고, 검색하고, 판단하는 모습**을 보여줌

### **ReAct 장점**

| **장점** | **설명** |
| --- | --- |
| **정확도 향상** | 복잡한 문제도 단계별로 해결하여 더 나은 성능을 냄 |
| **신뢰도 증가** | 중간 사고 과정을 보여줘서 사용자 신뢰가 높아짐 |
| **확장성** | 외부 도구나 API와 연동 가능 → 행동을 실행하는 에이전트로 확장 가능 |
| **사람과 협업** | AI가 어떻게 생각했는지 보여주므로 인간과의 상호작용이 쉬움 |

### **ReAct는 어디에 쓰일까?**

```
•	지식 기반 질의응답 시스템 (예: 회사 문서 기반 챗봇)
•	AI 에이전트 (예: 웹 검색, 코드 실행 등)
•	교육/튜터 챗봇
•	자동화된 분석/리서치 툴
```

### 정리

**ReAct는 언어 모델에게 “생각하고 행동하라”고 가르치는 프롬프트 전략**

단순한 답변 생성에서 벗어나, 복잡한 문제를 단계적으로 해결할 수 있는 **강력한 AI 프레임워크**

### **Chain-of-Thought (CoT)란?**

- **Chain-of-Thought**는 LLM에게 **답을 바로 말하지 않고**,**생각의 과정을 단계별로 말하게 유도하는 프롬프트 기법**

📌 간단히 말해,

**“정답만 말하지 말고, 생각 과정을 천천히 써줘”** 라고 시키는 방식.

### **목적**

•	복잡한 문제를 **논리적인 추론 과정을 통해 해결**하게 함

•	추론/계산/조건 판단이 필요한 경우 유용함

### **예시**

**프롬프트**

Q: Alice has 3 apples. She buys 2 more. How many does she have?

A: Let’s think step by step.

**출력 (CoT)**

She starts with 3 apples.

She buys 2 more, so now she has 3 + 2 = 5 apples.

**Answer: 5**

### **Tree-of-Thought (ToT)란?**

**Tree-of-Thought**는 CoT보다 진보된 방식으로, 여러 “생각의 가지(branch)”를 만들어 **병렬적으로 추론하고 평가**하는 방식.

### **목적**

•	단일 경로(Cot)만 따르지 않고, 다양한 가능성을 시도하고 **최적의 추론 경로를 선택**

•	**더 창의적이거나 복잡한 문제에 강함**

### 정리하자면

- ReAct : 단계별로 생각하고, 행동 (외부 API 연동) → 외부 도구들을 많이 사용할때 활용
- CoT : 단계별로 생각을 이어 붙이면서 논리적인 결과를 도출 할때 (수학 문제 같은 **정확한 답변**이 필요 할때)
- ToT : 문제해결을 위해서 여러 가능성을 나무 구조로 분기하여 탐색 (**다양한 해결책이나 전략을 고려**햐야 하는 작업 (게임 전략, 창의적인 문제 해결)에 유용

## Tools

구글에서는 Tools를 Extensions와 Functions로 나눠서 구분 하고 있는데,

### Extensions

예시로 아래처럼 Google Flights API를 Agent가 호출 해야 될때 어떻게 이거를 할 수 있는가?

![스크린샷 2025-03-11 오후 1.52.30.png](AI%20Agent%201b121b6b0f8980058c85e0fc5032da7c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-03-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.52.30.png)

사용자가 예를 들어서  “I want to book a flight from Austin to Zurich.” 를 구매 하고 싶다고 하면 Flights API를 콜링 한다. (Austin to Zurich 갈수 있는 비행기편들을 검색 하고 싶다고 하면 모두 알아서 제공 한다.)

만약, 목적지만 제시 했을때는 Agent 입장에서는 어디서 부터 출발 하는거지를 모르기 때문에 이 API 자체가 실패 하게 됨

그래서 그럴 경우를 대비해서 익스텐션이라는 거를 만들게 된다.

![스크린샷 2025-03-17 오후 8.14.31.png](AI%20Agent%201b121b6b0f8980058c85e0fc5032da7c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-03-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.14.31.png)

그래서 익스텐션이라고 하는 것은 API 콜링을 하기 전에 그 중간 단계에서 어느정도 이 데이터를 정리를 해 가지고 API 호출이 실패하지 않도록 이 익스텐션을 하나 만듬.

Agent한테 가르침 여러 예시들을 주면서 API 호출을 할때는 출발하는 도시와 도착하는 도시가 반드시 이어야 돼

어떤 아규먼트 또는 파라메터들이 필요한지 뭐가 필수적으로 필요한지 그걸 알려 주는 역할이 익스텐션이라고 보면 된다.

![스크린샷 2025-03-17 오후 8.18.26.png](AI%20Agent%201b121b6b0f8980058c85e0fc5032da7c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-03-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.18.26.png)

그래서 이런 익스텐션을 이제 여러개 쌓을 수가 있다는 건데, 그래서 이 툴들 중에서 예를 들어 플라이트 익스텐션은 Agent한테 만약에 항공편 예약을 해야 한다면 어떤 파라메터와 변수들이 필요한지 그거를 알려주고 애가 성공적으로 Flights API 콜링을 할수 있게끔 알려주는 거고 Map이나 Weather 같은 경우도 지역정보가 필요하다 알려줘서 각 API 들이 성공적으로 호출 될수 있도록 이런 익스텐션을 만들어 주는거다.

### Functions

소프트웨어 엔지니어링 세계에서 함수는 특정 작업을 수행하고 필요에 따라 재 사용할 수 있는 코드의 독립형 모듈로 정의 한다. 

 자주 사용하는 논리 라던지 그런 공식 들을 함수로 만들고 이 함수를 호출해서 바로 쓸 수 있도록 그런 것들을 정리를 해두듯이, 

에이전트에서도 매우 유사하게 작동하지만 

예를 들면 덧셈을 해주는 함수를 하나 만드는 거임

2+3 2+3 을 직접 계산해야 하는데 sum 이라는 함수를 하나 만들고 숫자 두개를 인자로 주면 두개의  덧셈의 결과만을 받아올수 있는 그런 함수를 만들수가 있다.

이런 평션도 에이전트들이 쓸수 있는데 앞서 말한 익스텐션과는 어떤 처이점이 있는지 알아 보자

- 평션은 live API 콜링은 하지 않음
- 평션은 클라이언트 사이드에서 호출이 되는거고 익스텐션은 에이전트가 직접 호출 함

![스크린샷 2025-03-17 오후 8.37.58.png](AI%20Agent%201b121b6b0f8980058c85e0fc5032da7c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-03-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.37.58.png)

유저한테 어떤 평션이 있는지, 유저가 어떤 정보들을 원하는지 결과들을 알려 준다.

![스크린샷 2025-03-17 오후 8.39.59.png](AI%20Agent%201b121b6b0f8980058c85e0fc5032da7c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-03-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.39.59.png)

그래서 비교해서 보면 익스텐션은 직접 API 콜을 하는데 Function은 클라이언트 사이드에서 호출이 이루어 진다.

그럼 평션은 언제 필요해?

개발자 입장에서 이 데이터가 어떻게 흐르는지 조금 더 컨트롤이 가능 하다.

- API 콜이 다른 레이어(Application stack 외에서) 호출 되어야 할때
- 보안등으로 agent가 api 를 직접 호출 할 수 없는 상태 (인증처리등 클라이언트가 직접 입력 해야 하는)
- 타이밍 또는 API Call 이후 기다려야 하는 상황 (외부 요소에 의해 확인 후 처리 …)
- 추가 적인 데이터나 로직이 필요할때, 직접 콜링하는 것보다 이렇게 평션을 고르는 경우가 생김 예를 들어서 API 콜링을 하고 답변이 천개정도 받는다고 했을때 비트 입장에서는 이 천개를 다 소화를 할 수 없기 때문에 그 답변중에 상위 10개만 추려서 에이전트에게 주는게

## Use cases

- **고객 서비스:** 챗봇, 가상 상담원 등을 통해 24시간 고객 응대를 제공
- **개인 비서:** 일정 관리, 이메일 처리, 정보 검색 등 개인 업무를 지원
- **데이터 분석:** 방대한 데이터를 분석하여 유용한 정보를 추출하고 예측
- **자동화:** 반복적인 작업을 자동화하여 생산성을 향상
- **이커머스 및 마케팅:** 개인화된 상품 추천 및 마케팅 전략을 최적화

## DataStore

AI 에이전트가 필요한 데이터를 저장, 관리, 검색하는 시스템

- **중요성:** AI 에이전트의 성능은 데이터 품질과 접근성에 크게 의존 함
- **종류:**
    - 관계형 데이터베이스: 구조화된 데이터를 효율적으로 저장하고 관리
    - NoSQL 데이터베이스: 비정형 데이터를 유연하게 저장하고 처리
    - 클라우드 스토리지: 대용량 데이터를 저렴하고 안전하게 저장
- **역할:**
    - 데이터 저장 및 관리: 다양한 형태의 데이터를 안전하게 저장하고 관리
    - 데이터 검색 및 제공: AI 에이전트가 필요로 하는 데이터를 빠르게 검색하여 제공
    - 데이터 통합 및 전처리: 다양한 소스의 데이터를 통합하고 AI 학습에 적합하게 전처리

AI 에이전트는 데이터 스토어에 저장된 데이터를 활용하여 다양한 작업을 수행하며, 데이터 스토어는 AI 에이전트의 효율적인 작동을 위한 필수적인 기반이다.

![스크린샷 2025-03-17 오후 8.52.45.png](AI%20Agent%201b121b6b0f8980058c85e0fc5032da7c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-03-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.52.45.png)

RAG처럼 LLM이 정보를 생성하기 전에 외부 지식 소스에서 관련 정보를 검색하여 활용하는 방식으로, LLM이 자체적으로 학습한 지식에만 의존하는것이 아니라, 필요한 정보를 실시간으로 찾아보고 참고하여 답변할때 데이터 스토어가 사용 된다.

![스크린샷 2025-03-17 오후 8.53.25.png](AI%20Agent%201b121b6b0f8980058c85e0fc5032da7c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-03-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.53.25.png)

기본적인 RAG 챗봇 흐름

사용자가 검색을 한번 하면, 컴퓨터가 이해 할 수 있는 임베딩값으로 변환

벡터 데이터베이스 (위에서 만든 모든 자료들을 저장)

임베딩값과 벡터 데이터베이스의 매칭해 가면서 유사도 점수가 가장 높은 순위별로 매기고, 그 중에 몇개를 에이전트한테 주면 그 값들을 토대로 답변을 생성 해 냄

## AI Agent 실습 예제

나무 위키(공개) 문서를 기반으로 질문에 답하는 AI Agent 챗봇 만들기

### 실습 목표

```
•	공개 위키 문서를 Vector DB에 저장하고

•	AI Agent가 사용자의 질문에 대해
→ 관련 문서를 검색(Retrieval)하고
→ 요약 또는 설명을 생성하고
→ 필요시 도구를 호출하는 구조까지 구성합니다.
```

### 실습 구성 요소

| **구성** | **기술 스택 / 오픈소스** |
| --- | --- |
| 개발언어 | Node.js + TypeScript |
| LLM | OpenAI GPT-4 (or Local LLM via Ollama) |
| Agent Framework | LangChain.js |
| Vector DB | Weaviate or Chroma |
| 문서 소스 | 나무위키 문서 (https://namu.wiki/w/) |
| Tool | Web Search, Math Tool, Custom Functions 등 |
| UI (선택) | Next.js or CLI 기반 |

### **실습 시나리오 (예제 흐름)**

1.	**문서 크롤링 및 전처리**

•	나무위키에서 특정 주제 문서 HTML → 텍스트 추출

•	문단별로 나누고, Embedding 생성

2.	**벡터 저장소 구축**

•	Weaviate/Chroma에 텍스트+임베딩 저장

3.	**LangChain Agent 구성**

•	LLM + Memory + Tool + Vector Retriever 구성

•	ReAct 스타일로 Agent 구성

4.	**Agent 질의 처리 흐름**

•	사용자가 질문: “나무위키의 GPT 항목 요약해줘”

•	Agent가 관련 문서 검색 → 요약

•	필요시 Web Search Tool 병행 호출

•	최종 답변 생성

**주요 코드 예시 (LangChain.js 기반)**

```jsx
import { initializeAgentExecutorWithOptions } from "langchain/agents";
import { ChatOpenAI } from "langchain/chat_models/openai";
import { WebBrowser } from "langchain/tools/webbrowser";
import { MemoryVectorStore } from "langchain/vectorstores/memory";

const model = new ChatOpenAI({ temperature: 0 });
const vectorStore = new MemoryVectorStore(/* load your documents here */);
const tools = [new WebBrowser(), vectorStore.asRetrieverTool()];

const executor = await initializeAgentExecutorWithOptions(tools, model, {
  agentType: "openai-functions",
  verbose: true,
});

// 실행 예
const result = await executor.run(
  "나무위키의 GPT 관련 항목 내용을 요약해줘"
);
console.log(result);
```

**실습을 통해 배우는 것**

•	Retrieval-Augmented Generation (RAG) 실습

•	LangChain에서 Agent와 Tool 사용법

•	Agent의 Orchestration 구조 이해

•	도메인 지식을 벡터화하여 질문 응답 시스템 만들기

**확장 아이디어**

•	나무위키 외에 내부 회사 문서 적용

•	OpenAI function calling으로 커스텀 API 연동

•	GPT-4-turbo + long-context로 대용량 요약

•	Tree-of-Thought 적용: 다양한 요약 시나리오 비교

---

## Appendix.

[https://www.kaggle.com/whitepaper-agents](https://www.kaggle.com/whitepaper-agents)

https://youtu.be/ZJzxje3rmnI?si=6SplhBNKyiHrCAyg

https://manus.im/