# Building future facing frontend architectures

> 원문: https://frontendmastery.com/posts/building-future-facing-frontend-architectures/

<br />

## 일반적인 멘탈 모델의 영향

- 우리가 가지고 있는 멘탈 모델과 사물에 대한 생각은 결국 우리의 결정에 큰 영향을 미칩니다.

- 대규모 프로젝트에서는 이러한 많은 결정이 항상 이루어지고 있기 때문에 전체적인 구조가 형성됩니다.

- 우리가 팀으로서 서비스를 만들 때 우리가 가지고 있는 모델을 명확히 하는것은 중요합니다.

다음 섹션에서는 아래 질문에 대한 답변을 위주로 살펴보겠습니다.

1. React와 유사한 (SPA) 프레임워크를 사용하여 서비스를 개발할 때 가장 일반적인 멘탈 모델은 무엇일까?

2. 컴포넌트 구조를 어떻게 구성할까?

3. 우리가 위의 내용들로 구성할때 어떤 트레이드 오프가 있을까?(애매하네요)

<br />

## 컴포넌트의 대한 생각

React는 가장 인기 있는 Component 기반의 프론트엔드 프레임웤입니다. [“Thinking in react”](https://reactjs.org/docs/thinking-in-react.html) 일반적으로 처음 시작할 때 읽는 첫 번째 아티클입니다.

컴포넌트를 구축할 때 다음과 같은 질문으로 기본 원칙을 알아봅시다.

- 컴포넌트가 가져야할 한 가지 책임은 무엇일까?

  - 좋은 컴포넌트 설계는 여러 로직을 대응하는 것이 아니라 하나의 결과를 도출하는 컴포넌트가 좋은 컴포넌트이다.

  - 하나의 컴포넌트에서 여러 비즈니스 로직이 들어가게 된다면 Component로서 그 기능을 제대로 못할 수 있다.

- 상태를 나타내는 최소한의 완전한 것은 무엇일까?

  - 작은 단위로 구현하는게 낫다. 이렇게 구현했을 경우 해당 컴포넌트는 유연하고 단순하며, 한 상태에 대해서만 대응하는것이 좋은 상태를 지닌 컴포넌트이다.

- 상태는 어디에 존재해야 할까?

  - 상태 관리에 대한 단상은 해당 아티클 범위 밖의 주제입니다.

  - 그러나 일반적으로 컴포넌트는 local 상태에 데이터로 만드는 경우가 좋다. 의존성(props)에 따라 내부적으로 로직이 변경된다면 해당 컴포넌트는 복잡성이 올라가 재사용성에 용이하지 못한 컴포넌트가 될 수 있습니다.

<br/>

> 컴포넌트는 이상적으로는 한 가지 작업만 수행해야한다. 이 부분은 atomic design pattern에 atom과 유사한 지향점입니다.

<br />

1. 위 원칙(생각)들을 벗어나는 경우는 어떤 경우인가?

2. 이러한 상황을 최대한 지양하려면 어떻게 해야 할까?

위 2개의 질문에 대한 부분은 아래 섹션들에서 다뤄보도록 하겠습니다.

<br />

## Top down vs Bottom up

해당 내용은 우리가 서비스를 만들어가면서 컴포넌트를 작성할 때 “추상화”와 “의존성”에 대한 내용입니다.

> 일반적으로 우리가 React를 사용할때 예시 하향식 (props drilling)

위 두 가지 방법은 보이는것보다 조금 더 중요할 수 있습니다. (딱봐도 중요해 보이긴 합니다.)

요 방식은 우리가 상태 관리에 대해서 논의할때 단반향, 양방향으로 이해해도 좋습니다.

일반적으로 하향식은 단방향 데이터 바인딩이고 상향식은 양방향 데이터 바인딩입니다. (상향식으로 개발한다고 해도 하향식을 사용할 수 밖에 없기 때문)

<br />

## Top down

Top down 방식은 일반적으로 직관적인 접근 방식입니다.

필자 경험으로는 개발을 진행할 떄 가장 일반적인 멘탈 모델로(?) 컴포넌트를 만들 때 사용하는 경향이 있습니다.

Top down 접근 방식은 어떤 모습일까?

서비스에 Side navigation를 만든다고 가정해봅시다.

Side navigation에 해당하는 컨텐츠는 API를 통해 가져오며 우리는 이 데이터를 통해 Side navigation Componenet를 만들어야합니다.

```javascript
const navItems = [
        { label: 'Home', to: '/home' },
        { label: 'Dashboards', to: '/dashboards' },
        { label: 'Settings', to: '/settings' },
    ]
    ...
    <SideNavigation items={navItems} />
```

이 코드와 위의 내용을 미루어 보았을 때 하향식 접근 방식은 상당히 간단하고 직관적으로 보입니다.

우리의 의도는 컴포넌트를 쉽고 재사용 가능하게 만드는 것입니다. 소비자는 렌더링하려는 항목을 전달하기만 하면 SideNavigation이 이를 처리합니다.

하지만 Top down 접근 방식에서 우리가 유의해야 할 몇 가지 사항이 있습니다.

1. 처음에 최상위 바운더리에서 시작하고, 하위에 상자에서 우리는 디자인을 구현했습니다.

2. Side navigation과 관련된 모든 것을 처리하는 단일 추상화입니다.

3. API는 종종 Top down 접근 방식이며, 그 이유는 위에서 필요한 데이터를 아래로 전달하는 top down 방식이기 때문입니다.

소규모 프로젝트의 경우 이 접근 방식이 잘못된 것은 아니지만. 많은 개발자가 빠른 배송을 시도하는 대규모 코드베이스의 경우 Top down 멘털 모델이 규모에 따라 문제가 되는 방법을 살펴보겠습니다.

<br />

## Top down이 잘못된 경우

Top down 방식은 직관적입니다. 컴포넌트를 구성하는 접근방식이 직접적으로 느껴지는 경우가 있습니다.

다음은 일반적인 시나리오입니다.

우리는 빠르게 개발 중인 프로젝트의 팀에 속해있으며, Side naviagtion을 업데이트 해야 하는 새로운 요구 사항이 있습니다.

상황이 빠르게 악화되기 시작할 것이며, 이것은 큰 모놀리식 컴포넌트를 만들 수 있는 일반적인 상황입니다.

### 우리가 수행해야될 일

- A - 이것이 올바른 추상화인지 생각해 보세요. 그렇지 않은 경우 스토리에 설명된 작업을 수행하기 전에 원래대로 되돌리세요.

- B - 새로운 Props를 받을 수 있도록 수정합니다. 해당 속성을 확인하는 간단한 조건 뒤에 새 기능을 추가합니다.

**샌디 메츠**는 이렇게 말합니다. (누군가요?)

> 기존 코드는 강력한 영향력을 발휘하고, 존재 자체가 그것이 옳다는 것과 필요한 것을 모두 보여줍니다. 우리는 코드를 유지하려는데 매우 의욕적입니다. 그러나 슬픈 진실은 코드가 복잡하고 이해할 수 없을 정도로, 즉 코드를 만들기 위한 투자가 깊어질수록 코드를 보유하는 것에 부담을 느낀다는 것입니다. = 매몰 비용 오류 (처음 코드가 만들어지고 리팩토링 없이 기능을 추가만 하다보면 본래 하던 일에 방향성을 잃고 거대해진 컴포넌트 혹은 feature 단위의 모습을 얘기하는 것 같습니다)

**매몰 비용 오류**는 우리가 자연적으로 손실을 피하는데 더 민감하기 때문에 존재합니다.

마감 시간이 촉박하거나 단순히 ‘스토리 포인트가 1’ 이라는 시간 압박을 더할 때, 우리가 A를 선택하지 못할 확률이 높습니다.

불행하게도 우리는 “Thinking in React”에서 설명한 기본 원칙 중 하나를 실패했습니다.

하기 쉬운 일은 종종 단순함으로 이어지지 않습니다. 그리고 우리를 단순함으로 이끄는 것은 대안에 비해 쉽지 않습니다.

일반적인 시나리오로 간단한 사이드바 예제에 적용해 보겠습니다.

첫 번째로 디자인 변경 요청이 들어옵니다. 그리고 탐색 항목에 대한 요구 사항을 추가하여 아이콘, 다양한 크기의 텍스트 및 일부는 SPA 페이지 전환이 아닌 링크가 되도록 해야합니다.

실제로 UI는 많은 시각적 상태를 유지하며, 구분 기호, 새탭에서 링크 열기, 기본 상태를 등을 원합니다.

네비게이션 아이템 목록을 사이드바 컴포넌트에 배열로 전달하기 때문에, 새로운 요구 사항마다 새로운 유형의 네비게이션 아이템과 그 다양한 상태를 구별하기 위한 객체에 몇 가지 속성을 추가해야합니다.

따라서 현재 링크인지 일반 탐색 항목인지에 해당하는 유형을 구분해야합니다.

`{ id, to, label, icon, size, type, separator, isSelected }`

그런 다음 `<SideNavigation />` 내부에서 유형을 확인하고 그에 따라 탐색 항목을 렌더링 해야합니다.

이런 작은 변환에 벌써부터 스멀스멀 망조의 기운이 나기 시작합니다.

여기에서 문제는 이와 같은 API가 있는 top down Component이며, API에 추가된 내용을 기반으로 내부 로직을 분기하여 요구 사항에 대해 대응해야 합니다.

> 작은 것에서 큰 것이 자라난다.

몇 주 후 새로운 기능이 요청되고 탐색 항목을 클릭하고 해당 항목 아래에 중첩된 하위 탐색으로 전환할 수 있어야 하며 뒤로 버튼을 사용하여 기본 탐색 목록으로 돌아갈 수 있는 기능을 구현해야합니다.

또한 관리자가 Drag and Drop 을 통해 탐색 항목을 재정렬 할 수 있는 기능을 원합니다.

이제 목록을 중첩하고 하위 목록을 상위 목록과 연결하고 일부 항목을 드래그할 수 있는지 여부에 대한 개념이 필요합니다.

위 내용을 적용하는 과정에서 우리가 초기에 설계했던 “목록을 전달하면 구성 요소가 나머지를 처리한다”라는 의도에 벗어나기 시작하고. 컴포넌트는 느리고 사이드 이펙트에 취약해져 위험하게 됩니다.

<br />

## 모놀리식 구성 요소의 유기적 성장

> 처음을 제외하고 모든 것은 Top down으로 만들어져야 합니다.

위 예시처럼 모놀리식 구성 요소는 너무나 많은 일을 진행하는 컴포넌트입니다.

너무 많은 데이터에 따른 구성 옵션을 가져오고, 너무 많은 상태를 관리하며, 너무 많은 UI를 출력합니다.

컴포넌트들은 종종 다른 의도로 설계되어 위에서 설명된 것처럼 유기적인 복잡성 증가를 통해 시간이 지남에 따라 너무 많은 일을 하게 됩니다.

단순한 컴포넌트로 시작한 것이, 몇번의 반복 내에서 새 기능을 빌드하면 모놀리식 구성 요소가 될 수 있습니다. (개인적으로 원티드에서 일하면서 대부분 이런 경험을 가진것 같습니다)

팀이 빠르게 개발해야하는 상황이고 동일한 코드베이스에서 작업할 때 여러 컴포넌트에 이런 일이 발생하면 프론트엔드는 빠르게 변경이 어려워지고 사용자는 더 느리게 느낄 수 있습니다.

모놀리식한 컴포넌트가 소리 없이 파괴되는 과정? 예시?들을 몇 가지 소개합니다.

- **너무 빠른 추상화로 인해 발생한다.**

또 하나의 미묘한 고차는 모놀리식한 구성 요소로 이어집니다. 소프트웨어 개발자로서 조기에 도입되는 몇 가지 일반적인 모델과 관련이 있습니다.

특히 DRY에 대한 고집(반복 되는 코드 금지)

실제로 서비스를 만들 때 반복 되는 코드에 대해서 악처럼 생각하는 경우가 있는 것 같습니다. 때때로는 반복되는 코드가 오히려 좋은 코드 퀄리티를 유지할 수 있다고 생각하네요

DRY가 초기에 뿌리내리고 컴포넌트가구성되어 있는 사이트에서 소량의 중복을 볼 수 있습니다.

중복되는 코드들을 하나의 컴포너ㅕㄴ트로 추상화하는 것은 좋은 일이라고 생각되기 쉽고, 우리는 너무 빨리 추상화에 돌입합니다.

모든 일에는 트레이드오프가 있습니다. 잘못된 추상화보다 추상화 없이 회복하는 것이 훨씬 쉽습니다.

아래에서 보게될 Bottom up 구조로 시작하게된다면 이러한 추상화를 유기적으로 달성할 수 있으며, 이를 조기에 작성하는 것을 피할 수 있습니다.

- **팀 간 코드 재사용을 방지합니다.**

우리가 개발을 할때 각자의 팀에서 필요로 하는 것과 유사한 디자인(형태)의 컴포넌트를 구현했거나 작업중인 것을 종종 발견하게 됩니다.

대부분의 경우 원하는 결과물에 90%를 수행하지만 약간의 수정이 필요합니다. 또한 전체 기능을 사용하지 않고 기능의 특정 부분을 재사용하고 싶을 수 있습니다.

<SideNavigation/> 과 같은 모놀리식 컴포넌트라면 기존 작업을 활용하기가 더욱 어려울 것입니다.

다른 사람의 패키지를 리팩토링 하거나 추상화하는 위험을 감수하는 대신에 다시 구현하고 패키지를 포크하는것이 더 쉬워집니다.

- **번들 크기를 부풀립니다.**

사용자에게 먼저 보여주기 위해 더 중요한 컴포넌트가 있습니다. 대규모 어플리케이션의 핵심 성능 전략은 우선 순위에 따라서 “단계”에 따른 비동기 로직으로 코드 실행 순서를 조정하는 것입니다 (흔히 우리가 알고있는 Lazy Loading)

- **Runtime 성능이 저하됩니다.**

상태 -> UI의 간단한 기능 모델을 가진 React와 같은 프레임워크는 매우 생산적입니다. 그러나 가상 DOM에서 변경된 사항을 확인하기 위한 조정 프로세스는 비용이 많이 듭니다. 모놀리식 구성 요소는 상태가 변경될 때 최소한의 항목만 다시 렌더링되도록 하기가 매우 어렵습니다.

일반적으로 모놀리식 구성 요소 및 top down 접근 방식 내에서 이러한 분할을 찾는 것은 어렵고 오류가 발생하기 쉬우며 종종 react memo() 를 과도하게 사용할 수 있습니다. (memo를 사용하는 것도 코스틀 지불해야한다)

<br />

## Building Bottom up

top down 방식에 비해 bottom up 방식은 직관적이지 않으며, 처음에는 개발 속도가 느릴 수 있습니다.

API를 재사용할 수 있는 여러 개의 작은 컴포넌트로 이루어집니다.

Top down과 Bottom up은 어떤 차이점이 있나요?

글로 설명하면 어려울 수 있으니 바로 예제로 가보겠습니다.

Sidebar 예제로 설명해보겠습니다.

```html
<SideNavigation>
        <Section>
            <NavItem to="/home">Home</NavItem>
            <NavItem to="/projects">Projects</NavItem>
            <Separator />
            <NavItem to="/settings">Settings</NavItem>
            <LinkItem to="/foo">Foo</NavItem>
        </Section>
        <NestedGroup>
            <NestedSection title="My projects">
                <NavItem to="/project-1">Project 1</NavItem>
                <NavItem to="/project-2">Project 2</NavItem>
                <NavItem to="/project-3">Project 3</NavItem>
                <LinkItem to="/foo.com">See documentation</LinkItem>
            </NestedSection>
        </NestedGroup>
    </SideNavigation>
```

Bottom up 접근 방식으로 구현된 SideNavigation인데 어떠신가요?

최종 결과는 어떠한 일을 하는지 조금 더 명확합니다.

그렇가면 Top down 방식에 비해서 어떤 이점들이 있는지 알아보겠습니다.

1. 컴포넌트를 사용하는 여러 팀은 실제로 가져오고 사용하고 싶은 컴포넌트에 대해서만 import합니다.

2. 또한 사용자에게 즉각적인 우선 순위가 아닌 분할 및 로드 요소를 보여주는 Lazy Loading을 쉽게 코딩할 수 있게 만듭니다.

3. 내부에 상태가 존재하지 않거나 적기 때문에 상태 변경으로 인해 재 렌더링이 적어 렌더링 성능이 더 좋고 관리하기 수월합니다.

4. 탐색 내에서 특정 책임이 있는 개별 구성 요소를 만들고 최적화할 수 있습니다. 또한 각 컴포넌트를 독립적으로 작업하고 최적화 할 수 있기 때문에 코드 구조 관점에서 더 확장이 가능합니다.

<br />

## Bottom Up에 요점은 무엇인가요?

Bottom up 접근 방식은 처음에 개발하는 속도는 느리지만 더 유연하기 때문에 장기적으로는 더 적은 코스트를 요합니다. 성급한 추상화를 더 쉽게 피할 수 있고 올바른 추상화가 분명해질 때까지 시간이 지남에 따라 변화의 물결을 탈 수 있습니다. 모놀리식 구성 요소의 확산을 방지하는 가장 좋은 방법입니다.

Bottom up 접근 방식에 장점은 "내가 원하는 것을 달성하기 위해 함께 구성할 수 있는 간단한 primitives 무엇인가"라는 전제로 시작하는 것과 이미 염두에 두고 있는 특정 추상화로 시작하는 것입니다.

> Agile 소프트웨어 개발의 가장 중요한 포인트는 반복의 가치 입니다. 이는 아키텍처를 포함한 모든 수준의 소프트웨어 개발에 적용됩니다.

<br />

## 모놀리식 구성 요소를 만들지 않기 위한 전략

- **Balancing single responsibility vs DRY.**

  - Bottom up 접근 방식으로 구현했을 때 종종 중복되는 코드가 있을 수 있습니다.

  - DRY는 우리가 개발자로서 처음 배우는 개념이고 물론 DRY한 코드가 좋습니다. 하지만 모든 것을 DRY하게 만들 필요가 있는지 확인하는것이 중요합니다.

- **Inversion of control**

  - 이 원칙을 이해하기 위한 간단한 예는 Callback과 Promise의 차이입니다.

  - Callback을 사용하면 해당 함수가 어디로 가는지, 몇번이나 호출되는지 무엇으로 호출되는지 알 필요가 없습니다.

  - Promise는 제어권을 개발자에게 되돌려 논리를 구성합니다.

```javascript
// may not know what onLoaded will do with the callback we pass it
onLoaded((stuff) => {
  doSomething(stuff);
});

// control stays with us to start composing logic as if the
// value was already there
onLoaded.then((stuff) => {
  doSomething(stuff);
});
```

Children을 통해서 “Props”를 노출하거나 개발자 측에서 제어하여 스타일을 렌더할 수 있습니다.

떄로는 개발자가 더 많은 일을 해야할거라는 생각이 들고 이와 관련하여 의존성 역전에 대한 혐오감이 있을 수 있습니다. 그러나 이것은 미래에 예측할 수 있다는 생각을 포기하고 개발자에게 유연성을 부여하는 것을 선택하는 것입니다.

어찌보면 위 예시는 우리가 개발을할 때 흔히 쉽게 예측해 오버엔지니어링을 하지 말라는 말로 받아들일 수 있을것 같습니다.

- Open For Extension

  - 이상적으로 구성 요소는 한 가지 작업을 수행합니다. 따라서 미리 만들어진 추상화의 경우 소비자는 필요한 한 가지를 가져 와서 포장하여 자체 기능으로 확장할 수 있습니다. 또는 기존 추상화를 구성하는 몇 가지 기본 요소를 선택하고 필요한 것을 구성할 수 있습니다.

- Leveraging storybook driven development

일반적으로 컴포넌트에서 관리되는 수많은 상태가 있습니다. 상태관리 라이브러리는 점점 더 다양한 이유로 인기를 얻고 있습니다.

스토리북과 별도로 UI 구성 요소를 구축할 때 모델을 채택하고 컴포넌트가 있을 수 있는 각 유형의 가능한 상태에 대한 스토리를 가질 수 있습니다.

이와 같이 사전에 수행하면 프로덕션에서 좋은 오류 상태를 구현하는 것을 잊었다는 사실을 깨닫지 못할 수 있습니다.

또한 작업중인 컴포넌트를 만드는데 필요한 모든 하위 컴포넌트를 식별하는데 도움이 됩니다.

- 탄력적인 컴포넌트로 이어지는 UI 컴포넌트를 독립적으로 구현할 때 스스로에게 물어볼 수 있는 몇가지 질문

  1.  접근 가능하니까?

  1.  로딩중일때는 어떻게 표시됩니까?

  1.  어떤 데이터에 의존성을 가지고있습니까?

  1.  에러 핸들링은 어떻게 합니까?

  1.  데이터의 일부만 사용할 수 있는 경우 어떻게 됩니까?

  1.  이 컴포넌트를 여러번 마운트하면 어떻게 됩니까? 어떤 종류의 에러가 있고 내부 상태를 관리한다면 그 상태가 일관적이길 기대할 수 있습니까?

  1.  얼마나 구성 가능합니까? API에 대한 생각

  1.  애니메이션에 대한 대응이 되어있습니까?

<br />

다음은 탄력적인 컴포넌트를 구현하는데 피해야 할 몇가지 일반적인 상황입니다.

- **Name components based on what they actually do.**

  - 의미가 있다면 긴 이름을 두려워하지 마십쇼

- **Avoid prop names that contain implementation details.**

  - 특히 UI 스타일에 대해서 props로 isSomething 과 같은 데이터를 보내지 않는게 좋습니다.

  - 해당 컴포넌트가 해당 Props이 전달될 때 다른 작업을 수행하도록 합니다.

- **Avoid defining components in the render method.**

  - 내부에서 여러 개의 내부 renderX, renderY 메서드가 있는 경우 모놀리식이 되고 있다는 신호일 수 있습니다.

<br />

## 모놀리식 컴포넌트 뽀개기

가능하다면 리팩토링을 자주 하십쇼. 그리고 일찍 리팩토링 하십쇼. 변경될 가능성이 있는 컴포넌트를 식별하고 이를 적극적으로 분해하는 것이 좋은 전략입니다.

프론트엔드 구조가 지나치게 복잡해진 상황이라면 어떻게 하시겠습니까?

두 가지 옵션이 있습니다.

1. 컴포넌트를 새로 만들고 점전적으로 마이그레이션한다.

2. 점진적으로 리팩토링을 진행한다.

컴포넌트 리팩토링 전략은 이 가이드에 범위를 벗어나지만 활용할 수 있는 리팩토링 패턴이 많이 있습니다.

React와 같은 프레임워크에서 컴포넌트는 실제로 위장된 기능일 뿐이며 함수라는 단어를 기존의 모든 검증된 리팩토링 기술에서 컴포넌트로 대체 할 수 있습니다. (??)

아래 자료를 참고해주세요.

- [Remove Flag Argument](https://refactoring.com/catalog/removeFlagArgument.html)

- [Replace Conditional with Polymorphism](https://refactoring.com/catalog/replaceConditionalWithPolymorphism.html)

- [Pull Up Field](https://refactoring.com/catalog/pullUpField.html)

- [Rename Variable](https://refactoring.com/catalog/renameVariable.html)

- [Inline Function](https://refactoring.com/catalog/inlineFunction.html)

<br />

## 결론

이 가이드에서 얘기된 내용에 대한 요약을 해보겠습니다.

1. **우리가 가지고있는 모델은 컴포넌트를 설계하고 구축할 때 내리는 많은 미세한 결정에 영향을** 미칩니다.

2. 컴포넌트를 구성할 때 Top down과 Bottom up으로 진행하면 규모에 따라 결과가 크게 달라질 수 있습니다.

3. Top down으로 설계하고 구축하면 모놀리식 구성 요소가 될 수 있습니다.

4. 모놀리식 구성 요소 생성을 피할 수 있습니다.
